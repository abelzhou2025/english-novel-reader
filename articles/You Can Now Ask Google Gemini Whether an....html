<!DOCTYPE html>

<html lang="zh">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>You Can Now Ask Google Gemini Whether an Image is AI-Generated or Not - English Novel Reader</title>
<link href="../styles.css" rel="stylesheet"/>
<style>
        body {
            font-family: Georgia, serif;
            background-color: #f9f7f4;
            margin: 0;
            padding: 0;
        }
        
        .article-content {
            max-width: 900px;
            margin: 100px auto 50px;
            padding: 40px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        .back-btn {
            display: inline-block;
            background-color: #5a3e2b;
            color: #fff;
            padding: 10px 20px;
            border-radius: 6px;
            text-decoration: none;
            font-family: 'Microsoft YaHei', sans-serif;
            font-size: 0.95rem;
            transition: all 0.3s ease;
            margin-bottom: 30px;
        }
        
        .back-btn:hover {
            background-color: #7a5c42;
            transform: translateY(-2px);
        }
        
        .article-title {
            font-family: Georgia, serif;
            font-size: 2rem;
            color: #2c2c2c;
            margin-bottom: 30px;
            line-height: 1.3;
            font-weight: 600;
        }
        
        .article-section {
            margin-bottom: 30px;
        }
        
        .section-heading {
            font-family: Georgia, serif;
            font-size: 1.5rem;
            color: #3a3a3a;
            margin-top: 35px;
            margin-bottom: 20px;
            font-weight: 600;
            line-height: 1.4;
        }
        
        .section-subheading {
            font-family: Georgia, serif;
            font-size: 1.2rem;
            color: #4a4a4a;
            margin-top: 25px;
            margin-bottom: 15px;
            font-weight: 600;
            line-height: 1.4;
        }
        
        .paragraph-block {
            margin-bottom: 25px;
        }
        
        .english-text {
            font-family: Georgia, serif;
            font-size: 1.1rem;
            color: #2c2c2c;
            line-height: 1.8;
            margin-bottom: 12px;
        }
        
        .chinese-text {
            font-family: 'Microsoft YaHei', 'SimHei', sans-serif;
            font-size: 1rem;
            color: #666;
            line-height: 1.8;
            padding-left: 20px;
            border-left: 3px solid #d4a76a;
            opacity: 0.7;
        }
        
        @media (max-width: 768px) {
            .article-content {
                margin: 80px 15px 30px;
                padding: 25px;
            }
            
            .article-title {
                font-size: 1.6rem;
            }
            
            .section-heading {
                font-size: 1.3rem;
            }
            
            .english-text {
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
<!-- Top Navigation -->
<nav class="top-nav">
<ul>
<li><a href="../index.html">首页</a></li>
<li><a href="../novels.html">小说</a></li>
<li><a class="active" href="../webnovels.html">网文</a></li>
    <li><a href="../news.html">新闻</a></li>
    <li><a href="../about.html">关于我</a></li>
</ul>
</nav>
<div class="article-content">
<a class="back-btn" href="../webnovels.html">← 返回网文列表</a>
<h1 class="article-title">You Can Now Ask Google Gemini Whether an Image is AI-Generated or Not</h1>
<div class="paragraph-block">
<p class="english-text">petapixel.com Matt Growcoot</p>
<p class="chinese-text">petapixel.com 马特·格罗库特</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
<div class="paragraph-block">
<p class="english-text">Google Keyword</p>
<p class="chinese-text">谷歌关键字</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
<div class="paragraph-block">
<p class="english-text">Google has a new feature that allows users to find out whether an image is AI-generated or not --- a much-needed tool in a world of AI slop.</p>
<p class="chinese-text">谷歌有一项新功能，可以让用户查明图像是否是人工智能生成的——这是人工智能世界急需的工具。</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
<div class="paragraph-block">
<p class="english-text">The new feature is available via Google Gemini 3, the latest installment of the company's LLM and multi-modal AI. To ascertain whether an image is AI-generated, simply open the Gemini app, upload the image, and ask something like: "Is this image AI-generated?"</p>
<p class="chinese-text">这项新功能可通过 Google Gemini 3 获得，这是该公司法学硕士和多模式人工智能的最新版本。要确定图像是否是 AI 生成的，只需打开 Gemini 应用程序，上传图像，然后询问以下问题：“这张图像是 AI 生成的吗？”</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
<div class="paragraph-block">
<p class="english-text">Gemini will give an answer, but it is predicated on whether that image contains SynthID, Google's digital watermarking technology that "embeds imperceptible signals into AI-generated content." Images that have been generated on one of Google's models, like Nano Banana, for example, will be flagged by Gemini as AI.</p>
<p class="chinese-text">Gemini 会给出答案，但这取决于该图像是否包含 SynthID，这是谷歌的数字水印技术，可以“将难以察觉的信号嵌入到人工智能生成的内容中”。例如，在 Google 模型之一（例如 Nano Banana）上生成的图像将被 Gemini 标记为 AI。</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
<div class="paragraph-block">
<p class="english-text">1/100:21PetaPixel RSS Continue watchingPolarPro's Knife for Photographers Does More Than Cut Stuffafter the ad</p>
<p class="chinese-text">1/100:21PetaPixel RSS 继续观看PolarPro 的摄影师刀在广告后不仅仅是切割东西</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
<div class="paragraph-block">
<p class="english-text">The video player is currently playing an ad.</p>
<p class="chinese-text">视频播放器当前正在播放广告。</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
<div class="paragraph-block">
<p class="english-text">"We introduced SynthID in 2023," Google says in a blog post. "Since then, over 20 billion AI-generated pieces of content have been watermarked using SynthID, and we have been testing our SynthID Detector, a verification portal, with journalists and media professionals."</p>
<p class="chinese-text">谷歌在博客文章中表示：“我们于 2023 年推出了 SynthID。”“从那时起，超过 200 亿条人工智能生成的内容已使用 SynthID 添加了水印，我们一直在与记者和媒体专业人士一起测试我们的 SynthID 检测器（一个验证门户）。”</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
<div class="paragraph-block">
<p class="english-text">While SynthID is Google's technology, the company says that it will "continue to invest in more ways to empower you to determine the origin and history of content online." It plans to incorporate the Coalition for Content Provenance and Authority (C2PA) standard so users will be able to check the provenance of an image created by AI models outside of Google's ecosystem.</p>
<p class="chinese-text">虽然 SynthID 是 Google 的技术，但该公司表示，它将“继续投资更多方法，让您能够确定在线内容的起源和历史。”它计划纳入内容来源和权威联盟（C2PA）标准，以便用户能够检查谷歌生态系统之外的人工智能模型创建的图像的来源。</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
<div class="paragraph-block">
<p class="english-text">"As part of this, rolling out this week, images generated by Nano Banana Pro (Gemini 3 Pro Image) in the Gemini app, Vertex AI, and Google Ads will have C2PA metadata embedded, providing further transparency into how these images were created," Google adds. "We look forward to expanding this capability to more products and surfaces in the coming months."</p>
<p class="chinese-text">谷歌补充道：“作为本周推出的计划的一部分，Gemini 应用程序、Vertex AI 和 Google Ads 中的 Nano Banana Pro (Gemini 3 Pro Image) 生成的图像将嵌入 C2PA 元数据，从而进一步提高这些图像的创建方式的透明度。”“我们期待在未来几个月内将这种功能扩展到更多产品和表面。”</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
<h2 class="section-heading">Can Google Gemini Tell You if an Image is AI-Generated?</h2>
<div class="paragraph-block">
<p class="english-text">I put Gemini's latest model to the test to see whether it can accurately spot an AI-generated image. Results below.
 First, I uploaded a real photo to Gemini. It correctly declared the image "was not created with Google AI."  Then, I uploaded an AI image made by ChatGPT. OpenAI does not use the SynthID system, which Gemini recognized. However, it did pick up on "several tell-tale signs" typical of AI-generated imagery. It highlighted the distorted Starbucks logos on the cups and the "blocky" look of the cartoon. It even went on to specifically name ChatGPT as the potential source.  Finally, I uploaded a photo edited on Google's AI studio. It picked up the SynthID and declared it to be "all or part" created with Google AI. It also comically picked up on "unrealistic animal behavior."</p>
<p class="chinese-text">我对 Gemini 的最新模型进行了测试，看看它是否能够准确地识别人工智能生成的图像。结果如下。
首先，我上传了一张真实的照片到Gemini。它正确地声明该图像“不是用 Google AI 创建的”。然后，我上传了一张ChatGPT制作的AI图像。OpenAI 不使用 Gemini 认可的 SynthID 系统。然而，它确实发现了人工智能生成图像中典型的“几个明显的迹象”。它突出了杯子上扭曲的星巴克标志和卡通的“块状”外观。它甚至还专门将 ChatGPT 指定为潜在来源。最后，我上传了一张在Google AI工作室编辑的照片。它选择了 SynthID 并声明它是“全部或部分”使用 Google AI 创建的。它还滑稽地提到了“不切实际的动物行为”。</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
<div class="paragraph-block">
<p class="english-text">So far, so good---and once C2PA is added, the system will feel much more complete. The best part is that it offers a relatively simple way to check whether an image was generated by AI. Photographers should consider adding a C2PA signature to their own photos, which can be done easily in Lightroom or Photoshop.</p>
<p class="chinese-text">到目前为止，一切都很好——一旦添加了 C2PA，系统就会感觉更加完整。最好的部分是它提供了一种相对简单的方法来检查图像是否由人工智能生成。摄影师应考虑在自己的照片中添加 C2PA 签名，这可以在 Lightroom 或 Photoshop 中轻松完成。</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
<div class="paragraph-block">
<p class="english-text">Read in Cubox</p>
<p class="chinese-text">在 Cubox 中阅读</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
</div>

    <!-- Translation Tooltip HTML -->
    <div class="translation-tooltip" id="translationTooltip" style="display: none; position: fixed; max-width: 400px; background-color: rgba(255, 255, 255, 0.98); border: 2px solid #5a3e2b; border-radius: 8px; padding: 15px; box-shadow: 0 4px 20px rgba(0,0,0,0.2); z-index: 1000; font-family: 'Microsoft YaHei', sans-serif;">
        <div class="tooltip-translation" style="color: #5a3e2b; font-size: 1rem; font-weight: 500; line-height: 1.6;">翻译中...</div>
    </div>
    <!-- Translation Script -->
    <script>
        // Article Translation Features
        // Features: Click-to-translate near cursor
        
        // Global variables
        let selectedParagraph = null;
        
        // Translation API (using free MyMemory API)
        const TRANSLATION_API = 'https://api.mymemory.translated.net/get';
        
        // DOM elements
        let translationTooltip;
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Get DOM elements
            translationTooltip = document.getElementById('translationTooltip');
            
            // Add click listener to close tooltip when clicking outside
            document.addEventListener('click', function(e) {
                // Check if click is outside tooltip and not on a selectable paragraph
                if (translationTooltip && 
                    !translationTooltip.contains(e.target) && 
                    !e.target.classList.contains('selectable')) {
                    hideTranslation();
                }
            });
            
            // Add selectable class to all English text paragraphs in articles
            const englishParagraphs = document.querySelectorAll('.english-text');
            englishParagraphs.forEach(paragraph => {
                // Only make English text selectable
                if (paragraph.textContent.trim()) {
                    paragraph.classList.add('selectable');
                    
                    // Add click listener for translation
                    paragraph.addEventListener('click', function(e) {
                        e.stopPropagation(); // Prevent document click from firing
                        handleParagraphClick(this, e);
                    });
                }
            });
        });
        
        // Handle paragraph click for translation
        function handleParagraphClick(element, event) {
            // Remove previous selection
            if (selectedParagraph) {
                selectedParagraph.classList.remove('selected');
            }
            
            // Mark as selected
            element.classList.add('selected');
            selectedParagraph = element;
            
            // Get the text to translate
            const textToTranslate = element.textContent;
            
            // Position tooltip near the click
            positionTooltip(event);
            
            // Show tooltip with loading state
            showTranslation(textToTranslate);
            
            // Fetch translation
            translateText(textToTranslate);
        }
        
        // Position tooltip near cursor but ensure it stays on screen
        function positionTooltip(event) {
            const tooltip = translationTooltip;
            const offset = 15; // Offset from cursor
            
            // Get viewport dimensions
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            // Initial position near cursor
            let left = event.pageX + offset;
            let top = event.pageY + offset;
            
            // Show tooltip temporarily to get its dimensions
            tooltip.style.display = 'block';
            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
            
            // Get tooltip dimensions
            const tooltipRect = tooltip.getBoundingClientRect();
            const tooltipWidth = tooltipRect.width;
            const tooltipHeight = tooltipRect.height;
            
            // Adjust if tooltip goes off right edge
            if (event.clientX + tooltipWidth + offset > viewportWidth) {
                left = event.pageX - tooltipWidth - offset;
            }
            
            // Adjust if tooltip goes off bottom edge
            if (event.clientY + tooltipHeight + offset > viewportHeight) {
                top = event.pageY - tooltipHeight - offset;
            }
            
            // Ensure tooltip doesn't go off left or top edges
            if (left < 10) left = 10;
            if (top < 80) top = 80; // Account for top nav
            
            // Set final position
            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
        }
        
        // Show translation tooltip
        function showTranslation(originalText) {
            const translationDiv = translationTooltip.querySelector('.tooltip-translation');
            
            // Show loading state
            translationDiv.textContent = '翻译中...';
            translationDiv.style.color = '#999';
            
            // Show tooltip
            translationTooltip.style.display = 'block';
        }
        
        // Hide translation tooltip
        function hideTranslation() {
            translationTooltip.style.display = 'none';
            if (selectedParagraph) {
                selectedParagraph.classList.remove('selected');
                selectedParagraph = null;
            }
        }
        
        // Translate text using free API
        async function translateText(text) {
            const translationDiv = translationTooltip.querySelector('.tooltip-translation');
            
            // Limit text length for API (MyMemory has a 500 character limit)
            const textToTranslate = text.length > 500 ? text.substring(0, 500) : text;
            
            // If text is too long, split it into chunks
            const maxChunkLength = 500; // MyMemory API limit
            
            if (text.length <= maxChunkLength) {
                // Short text - translate directly
                try {
                    const url = `${TRANSLATION_API}?q=${encodeURIComponent(text)}&langpair=en|zh-CN`;
                    const response = await fetch(url);
                    const data = await response.json();
                    
                    if (data.responseStatus === 200 && data.responseData) {
                        const translation = data.responseData.translatedText;
                        translationDiv.textContent = translation;
                        translationDiv.style.color = '#5a3e2b';
                    } else {
                        translationDiv.textContent = '翻译失败,请稍后重试';
                        translationDiv.style.color = '#d9534f';
                    }
                } catch (error) {
                    console.error('Translation error:', error);
                    translationDiv.textContent = '翻译服务暂时不可用';
                    translationDiv.style.color = '#d9534f';
                }
            } else {
                // Long text - split into chunks
                try {
                    // Split text into chunks of maxChunkLength, trying to break at sentence boundaries
                    const chunks = [];
                    let currentChunk = '';
                    
                    // First, try to split by sentence endings
                    const sentences = text.match(/[^.!?。！？]+[.!?。！？]*/g) || [text];
                    
                    for (const sentence of sentences) {
                        if ((currentChunk + sentence).length <= maxChunkLength) {
                            currentChunk += sentence;
                        } else {
                            if (currentChunk) {
                                chunks.push(currentChunk);
                            }
                            // If single sentence is too long, force split by maxChunkLength
                            if (sentence.length > maxChunkLength) {
                                for (let i = 0; i < sentence.length; i += maxChunkLength) {
                                    chunks.push(sentence.substring(i, i + maxChunkLength));
                                }
                                currentChunk = '';
                            } else {
                                currentChunk = sentence;
                            }
                        }
                    }
                    
                    if (currentChunk) {
                        chunks.push(currentChunk);
                    }
                    
                    // Translate each chunk
                    let fullTranslation = '';
                    for (let i = 0; i < chunks.length; i++) {
                        const chunk = chunks[i];
                        const url = `${TRANSLATION_API}?q=${encodeURIComponent(chunk)}&langpair=en|zh-CN`;
                        const response = await fetch(url);
                        const data = await response.json();
                        
                        if (data.responseStatus === 200 && data.responseData) {
                            fullTranslation += data.responseData.translatedText;
                            // Update display with progress
                            translationDiv.textContent = fullTranslation + ' [翻译中...]';
                        } else {
                            fullTranslation += '[翻译失败]';
                        }
                        
                        // Add small delay to avoid rate limiting
                        if (i < chunks.length - 1) {
                            await new Promise(resolve => setTimeout(resolve, 200));
                        }
                    }
                    
                    translationDiv.textContent = fullTranslation;
                    translationDiv.style.color = '#5a3e2b';
                } catch (error) {
                    console.error('Translation error:', error);
                    translationDiv.textContent = '翻译服务暂时不可用';
                    translationDiv.style.color = '#d9534f';
                }
            }
        }
        
        // Add CSS for selected state
        const style = document.createElement('style');
        style.textContent = `
            .selectable {
                cursor: pointer;
                transition: background-color 0.2s ease;
                padding: 2px 4px;
                border-radius: 3px;
            }
            
            .selectable:hover {
                background-color: rgba(212, 167, 106, 0.2);
            }
            
            .selectable.selected {
                background-color: rgba(212, 167, 106, 0.4);
            }
            
            .translation-tooltip {
                animation: fadeIn 0.2s ease;
            }
            
            @keyframes fadeIn {
                from {
                    opacity: 0;
                    transform: translateY(-5px);
                }
                to {
                    opacity: 1;
                    transform: translateY(0);
                }
            }
        `;
        document.head.appendChild(style);
    </script>
    </body>
</html>