<!DOCTYPE html>

<html lang="zh">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Google Tests Direct Link To AI Mode From Search - English Novel Reader</title>
<link href="../styles.css" rel="stylesheet"/>
<style>
        body {
            font-family: Georgia, serif;
            background-color: #f9f7f4;
            margin: 0;
            padding: 0;
        }
        
        .article-content {
            max-width: 900px;
            margin: 100px auto 50px;
            padding: 40px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        .back-btn {
            display: inline-block;
            background-color: #5a3e2b;
            color: #fff;
            padding: 10px 20px;
            border-radius: 6px;
            text-decoration: none;
            font-family: 'Microsoft YaHei', sans-serif;
            font-size: 0.95rem;
            transition: all 0.3s ease;
            margin-bottom: 30px;
        }
        
        .back-btn:hover {
            background-color: #7a5c42;
            transform: translateY(-2px);
        }
        
        .article-title {
            font-family: Georgia, serif;
            font-size: 2rem;
            color: #2c2c2c;
            margin-bottom: 30px;
            line-height: 1.3;
            font-weight: 600;
        }
        
        .article-section {
            margin-bottom: 30px;
        }
        
        .section-heading {
            font-family: Georgia, serif;
            font-size: 1.5rem;
            color: #3a3a3a;
            margin-top: 35px;
            margin-bottom: 20px;
            font-weight: 600;
            line-height: 1.4;
        }
        
        .section-subheading {
            font-family: Georgia, serif;
            font-size: 1.2rem;
            color: #4a4a4a;
            margin-top: 25px;
            margin-bottom: 15px;
            font-weight: 600;
            line-height: 1.4;
        }
        
        .paragraph-block {
            margin-bottom: 25px;
        }
        
        .english-text {
            font-family: Georgia, serif;
            font-size: 1.1rem;
            color: #2c2c2c;
            line-height: 1.8;
            margin-bottom: 12px;
        }
        
        .chinese-text {
            font-family: 'Microsoft YaHei', 'SimHei', sans-serif;
            font-size: 1rem;
            color: #666;
            line-height: 1.8;
            padding-left: 20px;
            border-left: 3px solid #d4a76a;
            opacity: 0.7;
        }
        
        @media (max-width: 768px) {
            .article-content {
                margin: 80px 15px 30px;
                padding: 25px;
            }
            
            .article-title {
                font-size: 1.6rem;
            }
            
            .section-heading {
                font-size: 1.3rem;
            }
            
            .english-text {
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
<!-- Top Navigation -->
<nav class="top-nav">
<ul>
<li><a href="../index.html">首页</a></li>
<li><a href="../novels.html">小说</a></li>
<li><a class="active" href="../webnovels.html">网文</a></li>
    <li><a href="../news.html">新闻</a></li>
    <li><a href="../about.html">关于我</a></li>
</ul>
</nav>
<div class="article-content">
<a class="back-btn" href="../webnovels.html">← 返回网文列表</a>
<h1 class="article-title">Google Tests Direct Link To AI Mode From Search</h1>
<div class="paragraph-block">
<p class="english-text">www.socialmediatoday.com Andrew Hutchinson</p>
<p class="chinese-text">www.socialmediatoday.com 安德鲁·哈钦森</p>
</div>
<div class="paragraph-block">

</div>
<div class="paragraph-block">
<p class="english-text">This audio is auto-generated. Please let us know if you have feedback.</p>
<p class="chinese-text">该音频是自动生成的。如果您有任何反馈，请告诉我们。</p>
</div>
<div class="paragraph-block">

</div>
<div class="paragraph-block">
<p class="english-text">This is probably not great news for web managers who are concerned that they're losing traffic to AI chatbots.</p>
<p class="chinese-text">对于担心自己会因人工智能聊天机器人而失去流量的网络管理员来说，这可能不是什么好消息。</p>
</div>
<div class="paragraph-block">

</div>
<div class="paragraph-block">
<p class="english-text">Google has launched a new test that will guide users into its "AI Mode" chatbot experience direct from Search results.</p>
<p class="chinese-text">谷歌推出了一项新测试，将引导用户直接从搜索结果进入其“AI模式”聊天机器人体验。</p>
</div>
<div class="paragraph-block">

</div>
<div class="paragraph-block">
<p class="english-text">As you can see in this sequence, now, for users in the test at least, if you tap on the "Show More" prompt on the AI Overview response to your query, a new "Ask anything" prompt will be displayed in the lower screen of the SERP. If you then go to ask a follow-up question, you'll be transferred from traditional Search and into Google's AI chatbot window instead.</p>
<p class="chinese-text">正如您在此序列中所看到的，现在，至少对于测试中的用户来说，如果您点击 AI 概述响应您的查询上的“显示更多”提示，则 SERP 的下部屏幕中将显示一个新的“询问任何内容”提示。如果您随后提出后续问题，您将从传统搜索转移到 Google 的人工智能聊天机器人窗口。</p>
</div>
<div class="paragraph-block">

</div>
<div class="paragraph-block">
<p class="english-text">As explained by Google Search VP Robby Stein:</p>
<p class="chinese-text">正如 Google 搜索副总裁 Robby Stein 所解释的：</p>
</div>
<div class="paragraph-block">

</div>
<div class="paragraph-block">
<p class="english-text">" We're starting to test a new way to seamlessly go deeper in AI Mode directly from the Search results page on mobile, globally. This brings us closer to our vision for Search: just ask whatever's on your mind -- no matter how long or complex -- and find exactly what you need. You shouldn't have to think about where or how to ask your question."</p>
<p class="chinese-text">“我们开始测试一种新方法，可以直接从全球移动设备上的搜索结果页面无缝地深入人工智能模式。这使我们更接近我们的搜索愿景：只需提出您想到的任何问题 - 无论多长或多复杂 - 并准确找到您需要的内容。您不必考虑在哪里或如何提出您的问题。”</p>
</div>
<div class="paragraph-block">

</div>
<div class="paragraph-block">
<p class="english-text">The idea is that this will make Search more conversational, but it will also mean that more Google Search traffic gets transferred into an AI search query. And with research showing that searchers who are shown an AI summary are significantly less likely to click through on an external link, the addition of even more detailed AI responses within regular Search could mean even fewer referral clicks overall.</p>
<p class="chinese-text">这个想法是，这将使搜索更具对话性，但这也意味着更多的谷歌搜索流量会转移到人工智能搜索查询中。研究表明，看到人工智能摘要的搜索者点击外部链接的可能性明显降低，在常规搜索中添加更详细的人工智能响应可能意味着整体推荐点击次数会更少。</p>
</div>
<div class="paragraph-block">

</div>
<div class="paragraph-block">
<p class="english-text">Though Google itself has disputed this claim.</p>
<p class="chinese-text">尽管谷歌本身对这一说法提出了异议。</p>
</div>
<div class="paragraph-block">

</div>
<div class="paragraph-block">
<p class="english-text">Back in August, Google reported that total organic click volume from Google Search to websites hasn't fluctuated much as a result of AI its overviews.</p>
<p class="chinese-text">早在八月份，谷歌就报告称，由于人工智能的概述，从谷歌搜索到网站的总有机点击量并没有太大波动。</p>
</div>
<div class="paragraph-block">

</div>
<div class="paragraph-block">
<p class="english-text">Google also said that:</p>
<p class="chinese-text">谷歌还表示：</p>
</div>
<div class="paragraph-block">

</div>
<div class="paragraph-block">
<p class="english-text">"Average click quality has increased and we're actually sending slightly more quality clicks to websites than a year ago (by quality clicks, we mean those where users don't quickly click back --- typically a signal that a user is interested in the website)."</p>
<p class="chinese-text">“平均点击质量有所提高，实际上，我们向网站发送的质量点击量比一年前略高（所谓质量点击量，是指用户不会快速返回的点击量——通常是用户对网站感兴趣的信号）。”</p>
</div>
<div class="paragraph-block">

</div>
<div class="paragraph-block">
<p class="english-text">So Google's framing this as a better result, in that sites are getting more qualified, engaged traffic, because of the additional context provided by its AI overviews.</p>
<p class="chinese-text">[翻译失败: So Google's framing this as a ...]</p>
</div>
<div class="paragraph-block">

</div>
<div class="paragraph-block">
<p class="english-text">I guess, by extension, that should mean that this test qualifies that traffic even more, but it does seem more likely that people are going to just get their answers from their chatbot conversations, as opposed to having to click through to an external site.</p>
<p class="chinese-text">[翻译失败: I guess, by extension, that sh...]</p>
</div>
<div class="paragraph-block">

</div>
<div class="paragraph-block">
<p class="english-text">In any event, it's another element to watch for those working on SEO, further complicating what's already become a secondary consideration, due to the instability of search traffic.</p>
<p class="chinese-text">[翻译失败: In any event, it's another ele...]</p>
</div>
<div class="paragraph-block">

</div>
<div class="paragraph-block">
<p class="english-text">Read in Cubox</p>
<p class="chinese-text">[翻译失败: Read in Cubox...]</p>
</div>
<div class="paragraph-block">

</div>
</div>

    <!-- Translation Tooltip HTML -->
    <div class="translation-tooltip" id="translationTooltip" style="display: none; position: fixed; max-width: 400px; background-color: rgba(255, 255, 255, 0.98); border: 2px solid #5a3e2b; border-radius: 8px; padding: 15px; box-shadow: 0 4px 20px rgba(0,0,0,0.2); z-index: 1000; font-family: 'Microsoft YaHei', sans-serif;">
        <div class="tooltip-translation" style="color: #5a3e2b; font-size: 1rem; font-weight: 500; line-height: 1.6;">翻译中...</div>
    </div>
    <!-- Translation Script -->
    <script>
        // Article Translation Features
        // Features: Click-to-translate near cursor
        
        // Global variables
        let selectedParagraph = null;
        
        // Translation API (using free MyMemory API)
        const TRANSLATION_API = 'https://api.mymemory.translated.net/get';
        
        // DOM elements
        let translationTooltip;
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Get DOM elements
            translationTooltip = document.getElementById('translationTooltip');
            
            // Add click listener to close tooltip when clicking outside
            document.addEventListener('click', function(e) {
                // Check if click is outside tooltip and not on a selectable paragraph
                if (translationTooltip && 
                    !translationTooltip.contains(e.target) && 
                    !e.target.classList.contains('selectable')) {
                    hideTranslation();
                }
            });
            
            // Add selectable class to all English text paragraphs in articles
            const englishParagraphs = document.querySelectorAll('.english-text');
            englishParagraphs.forEach(paragraph => {
                // Only make English text selectable
                if (paragraph.textContent.trim()) {
                    paragraph.classList.add('selectable');
                    
                    // Add click listener for translation
                    paragraph.addEventListener('click', function(e) {
                        e.stopPropagation(); // Prevent document click from firing
                        handleParagraphClick(this, e);
                    });
                }
            });
        });
        
        // Handle paragraph click for translation
        function handleParagraphClick(element, event) {
            // Remove previous selection
            if (selectedParagraph) {
                selectedParagraph.classList.remove('selected');
            }
            
            // Mark as selected
            element.classList.add('selected');
            selectedParagraph = element;
            
            // Get the text to translate
            const textToTranslate = element.textContent;
            
            // Position tooltip near the click
            positionTooltip(event);
            
            // Show tooltip with loading state
            showTranslation(textToTranslate);
            
            // Fetch translation
            translateText(textToTranslate);
        }
        
        // Position tooltip near cursor but ensure it stays on screen
        function positionTooltip(event) {
            const tooltip = translationTooltip;
            const offset = 15; // Offset from cursor
            
            // Get viewport dimensions
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            // Initial position near cursor
            let left = event.pageX + offset;
            let top = event.pageY + offset;
            
            // Show tooltip temporarily to get its dimensions
            tooltip.style.display = 'block';
            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
            
            // Get tooltip dimensions
            const tooltipRect = tooltip.getBoundingClientRect();
            const tooltipWidth = tooltipRect.width;
            const tooltipHeight = tooltipRect.height;
            
            // Adjust if tooltip goes off right edge
            if (event.clientX + tooltipWidth + offset > viewportWidth) {
                left = event.pageX - tooltipWidth - offset;
            }
            
            // Adjust if tooltip goes off bottom edge
            if (event.clientY + tooltipHeight + offset > viewportHeight) {
                top = event.pageY - tooltipHeight - offset;
            }
            
            // Ensure tooltip doesn't go off left or top edges
            if (left < 10) left = 10;
            if (top < 80) top = 80; // Account for top nav
            
            // Set final position
            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
        }
        
        // Show translation tooltip
        function showTranslation(originalText) {
            const translationDiv = translationTooltip.querySelector('.tooltip-translation');
            
            // Show loading state
            translationDiv.textContent = '翻译中...';
            translationDiv.style.color = '#999';
            
            // Show tooltip
            translationTooltip.style.display = 'block';
        }
        
        // Hide translation tooltip
        function hideTranslation() {
            translationTooltip.style.display = 'none';
            if (selectedParagraph) {
                selectedParagraph.classList.remove('selected');
                selectedParagraph = null;
            }
        }
        
        // Translate text using free API
        async function translateText(text) {
            const translationDiv = translationTooltip.querySelector('.tooltip-translation');
            
            // Limit text length for API (MyMemory has a 500 character limit)
            const textToTranslate = text.length > 500 ? text.substring(0, 500) : text;
            
            // If text is too long, split it into chunks
            const maxChunkLength = 500; // MyMemory API limit
            
            if (text.length <= maxChunkLength) {
                // Short text - translate directly
                try {
                    const url = `${TRANSLATION_API}?q=${encodeURIComponent(text)}&langpair=en|zh-CN`;
                    const response = await fetch(url);
                    const data = await response.json();
                    
                    if (data.responseStatus === 200 && data.responseData) {
                        const translation = data.responseData.translatedText;
                        translationDiv.textContent = translation;
                        translationDiv.style.color = '#5a3e2b';
                    } else {
                        translationDiv.textContent = '翻译失败,请稍后重试';
                        translationDiv.style.color = '#d9534f';
                    }
                } catch (error) {
                    console.error('Translation error:', error);
                    translationDiv.textContent = '翻译服务暂时不可用';
                    translationDiv.style.color = '#d9534f';
                }
            } else {
                // Long text - split into chunks
                try {
                    // Split text into chunks of maxChunkLength, trying to break at sentence boundaries
                    const chunks = [];
                    let currentChunk = '';
                    
                    // First, try to split by sentence endings
                    const sentences = text.match(/[^.!?。！？]+[.!?。！？]*/g) || [text];
                    
                    for (const sentence of sentences) {
                        if ((currentChunk + sentence).length <= maxChunkLength) {
                            currentChunk += sentence;
                        } else {
                            if (currentChunk) {
                                chunks.push(currentChunk);
                            }
                            // If single sentence is too long, force split by maxChunkLength
                            if (sentence.length > maxChunkLength) {
                                for (let i = 0; i < sentence.length; i += maxChunkLength) {
                                    chunks.push(sentence.substring(i, i + maxChunkLength));
                                }
                                currentChunk = '';
                            } else {
                                currentChunk = sentence;
                            }
                        }
                    }
                    
                    if (currentChunk) {
                        chunks.push(currentChunk);
                    }
                    
                    // Translate each chunk
                    let fullTranslation = '';
                    for (let i = 0; i < chunks.length; i++) {
                        const chunk = chunks[i];
                        const url = `${TRANSLATION_API}?q=${encodeURIComponent(chunk)}&langpair=en|zh-CN`;
                        const response = await fetch(url);
                        const data = await response.json();
                        
                        if (data.responseStatus === 200 && data.responseData) {
                            fullTranslation += data.responseData.translatedText;
                            // Update display with progress
                            translationDiv.textContent = fullTranslation + ' [翻译中...]';
                        } else {
                            fullTranslation += '[翻译失败]';
                        }
                        
                        // Add small delay to avoid rate limiting
                        if (i < chunks.length - 1) {
                            await new Promise(resolve => setTimeout(resolve, 200));
                        }
                    }
                    
                    translationDiv.textContent = fullTranslation;
                    translationDiv.style.color = '#5a3e2b';
                } catch (error) {
                    console.error('Translation error:', error);
                    translationDiv.textContent = '翻译服务暂时不可用';
                    translationDiv.style.color = '#d9534f';
                }
            }
        }
        
        // Add CSS for selected state
        const style = document.createElement('style');
        style.textContent = `
            .selectable {
                cursor: pointer;
                transition: background-color 0.2s ease;
                padding: 2px 4px;
                border-radius: 3px;
            }
            
            .selectable:hover {
                background-color: rgba(212, 167, 106, 0.2);
            }
            
            .selectable.selected {
                background-color: rgba(212, 167, 106, 0.4);
            }
            
            .translation-tooltip {
                animation: fadeIn 0.2s ease;
            }
            
            @keyframes fadeIn {
                from {
                    opacity: 0;
                    transform: translateY(-5px);
                }
                to {
                    opacity: 1;
                    transform: translateY(0);
                }
            }
        `;
        document.head.appendChild(style);
    </script>
    </body>
</html>