<!DOCTYPE html>

<html lang="zh">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>How reliable is AI information? - English Novel Reader</title>
<link href="../styles.css" rel="stylesheet"/>
<style>
        body {
            font-family: Georgia, serif;
            background-color: #f9f7f4;
            margin: 0;
            padding: 0;
        }
        
        .article-content {
            max-width: 900px;
            margin: 100px auto 50px;
            padding: 40px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        .back-btn {
            display: inline-block;
            background-color: #5a3e2b;
            color: #fff;
            padding: 10px 20px;
            border-radius: 6px;
            text-decoration: none;
            font-family: 'Microsoft YaHei', sans-serif;
            font-size: 0.95rem;
            transition: all 0.3s ease;
            margin-bottom: 30px;
        }
        
        .back-btn:hover {
            background-color: #7a5c42;
            transform: translateY(-2px);
        }
        
        .article-title {
            font-family: Georgia, serif;
            font-size: 2rem;
            color: #2c2c2c;
            margin-bottom: 30px;
            line-height: 1.3;
            font-weight: 600;
        }
        
        .article-section {
            margin-bottom: 30px;
        }
        
        .section-heading {
            font-family: Georgia, serif;
            font-size: 1.5rem;
            color: #3a3a3a;
            margin-top: 35px;
            margin-bottom: 20px;
            font-weight: 600;
            line-height: 1.4;
        }
        
        .section-subheading {
            font-family: Georgia, serif;
            font-size: 1.2rem;
            color: #4a4a4a;
            margin-top: 25px;
            margin-bottom: 15px;
            font-weight: 600;
            line-height: 1.4;
        }
        
        .paragraph-block {
            margin-bottom: 25px;
        }
        
        .english-text {
            font-family: Georgia, serif;
            font-size: 1.1rem;
            color: #2c2c2c;
            line-height: 1.8;
            margin-bottom: 12px;
        }
        
        .chinese-text {
            font-family: 'Microsoft YaHei', 'SimHei', sans-serif;
            font-size: 1rem;
            color: #666;
            line-height: 1.8;
            padding-left: 20px;
            border-left: 3px solid #d4a76a;
            opacity: 0.7;
        }
        
        @media (max-width: 768px) {
            .article-content {
                margin: 80px 15px 30px;
                padding: 25px;
            }
            
            .article-title {
                font-size: 1.6rem;
            }
            
            .section-heading {
                font-size: 1.3rem;
            }
            
            .english-text {
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
<!-- Top Navigation -->
<nav class="top-nav">
<ul>
<li><a href="../index.html">首页</a></li>
<li><a href="../novels.html">小说</a></li>
<li><a class="active" href="../webnovels.html">网文</a></li>
    <li><a href="../news.html">新闻</a></li>
    <li><a href="../about.html">关于我</a></li>
</ul>
</nav>
<div class="article-content">
<a class="back-btn" href="../webnovels.html">← 返回网文列表</a>
<h1 class="article-title">How reliable is AI information?</h1>
<div class="paragraph-block">
<p class="english-text">msutoday.msu.edu Nov. 12, 2025 | Read time 4 min</p>
<p class="chinese-text">msutoday.msu.edu 2025 年 11 月 12 日 |阅读时间 4 分钟</p>
</div>
<div class="paragraph-block">

</div>
<div class="paragraph-block">
<p class="english-text">While artificial intelligence, or AI, tools like ChatGPT might be great for helping you pick where to go for dinner or which TV show to binge watch, would you trust it to make decisions about your medical care or finances?</p>
<p class="chinese-text">虽然像 ChatGPT 这样的人工智能或 AI 工具可能非常适合帮助您选择去哪里吃饭或观看哪些电视节目，但您是否相信它可以做出有关您的医疗保健或财务的决定？</p>
</div>
<div class="paragraph-block">

</div>
<div class="paragraph-block">
<p class="english-text">AI tools like ChatGPT and Gemini include a disclaimer that the information they find scanning the internet may not always be accurate. If someone was researching a topic that they didn't know anything about, how would they know how to confirm the information as truth? As AI tools become smarter and gain more widespread use in daily life, so do the stakes for the accuracy and dependability of using this evolving technology.</p>
<p class="chinese-text">ChatGPT 和 Gemini 等人工智能工具包含一项免责声明，即它们通过扫描互联网找到的信息可能并不总是准确的。如果有人正在研究一个他们一无所知的主题，他们如何知道如何确认该信息的真实性？随着人工智能工具变得更加智能并在日常生活中得到更广泛的使用，使用这种不断发展的技术的准确性和可靠性的风险也随之增加。</p>
</div>
<div class="paragraph-block">

</div>
<div class="paragraph-block">
<p class="english-text">Michigan State University researchers aim to increase the reliability of AI information. To do this, they have developed a new method that acts like a trust meter and reports the accuracy of information produced from AI large language models, or LLMs.</p>
<p class="chinese-text">密歇根州立大学的研究人员旨在提高人工智能信息的可靠性。为此，他们开发了一种新方法，该方法类似于信任表，报告人工智能大型语言模型（LLM）生成的信息的准确性。</p>
</div>
<div class="paragraph-block">

</div>
<div class="paragraph-block">
<p class="english-text">Reza Khan Mohammadi, a doctoral student in MSU's ++College of Engineering++, and ++Mohammad Ghassemi++, an assistant professor in the Department of Computer Science and Engineering, collaborated with researchers from Henry Ford Health and JPMorganChase Artificial Intelligence Research on this work.</p>
<p class="chinese-text">密歇根州立大学++工程学院++的博士生Reza Khan Mohammadi和计算机科学与工程系的助理教授++Mohammad Ghassemi++与Henry Ford Health和摩根大通人工智能研究中心的研究人员合作开展了这项工作。</p>
</div>
<div class="paragraph-block">

</div>
<div class="paragraph-block">
<p class="english-text">"As more people rely on LLMs in their daily work, there's a fundamental question of trust that lingers in the back of our minds: Is the information we're getting actually correct?" said Khan Mohammadi. "Our goal was to create a practical 'trust meter' that could give users a clear signal of the model's true confidence, especially in high-stakes domains where an error can have serious consequences."
 The CCPS method questions AI to see how confident the answer is. Credit: Reza Khan Mohammadi/Michigan State University</p>
<p class="chinese-text">“随着越来越多的人在日常工作中依赖法学硕士，我们脑海中萦绕着一个基本的信任问题：我们获得的信息真的正确吗？”汗·穆罕默德说。“我们的目标是创建一个实用的‘信任表’，可以向用户提供模型真实可信度的清晰信号，特别是在错误可能导致严重后果的高风险领域。”
CCPS 方法询问 AI，看看答案的可信度如何。图片来源：Reza Khan Mohammadi/密歇根州立大学</p>
</div>
<div class="paragraph-block">

</div>
<div class="paragraph-block">
<p class="english-text">Though a person can repeatedly ask an AI tool the same question to check for consistency --- a slow and energy costly process --- the MSU-led team developed a more efficient internal approach. The new method called Calibrating LLM Confidence by Probing Perturbed Representation Stability, or CCPS, applies tiny nudges to an LLM's internal state while it's forming an answer. These nudges "poke" at the foundation of the answer to see if the answer is strong and stable or weak and unreliable.</p>
<p class="chinese-text">尽管一个人可以反复向人工智能工具提出同样的问题来检查一致性——这是一个缓慢且耗费能源的过程——但密歇根州立大学领导的团队开发了一种更有效的内部方法。这种新方法称为“通过探测扰动表征稳定性来校准法学硕士信心”（CCPS），在法学硕士形成答案时对其内部状态施加微小的推动。这些推动“戳”到答案的基础，看看答案是强而稳定的还是弱且不可靠的。</p>
</div>
<div class="paragraph-block">

</div>
<div class="paragraph-block">
<p class="english-text">"The idea is simple but powerful, and if small internal changes cause the model's potential answer to shift, it probably wasn't very confident to begin with," said Ghassemi. "A genuinely confident decision should be stable and resilient, like a well-built bridge. We essentially test that bridge's integrity."</p>
<p class="chinese-text">加塞米说：“这个想法很简单，但功能强大，如果微小的内部变化导致模型的潜在答案发生变化，那么它一开始可能就不太有信心。”“真正自信的决定应该是稳定和有弹性的，就像一座精心建造的桥梁。我们本质上是测试这座桥梁的完整性。”</p>
</div>
<div class="paragraph-block">

</div>
<div class="paragraph-block">
<p class="english-text">The researchers have found that their method is significantly better at predicting when an LLM is correct. Compared to the strongest prior techniques, the CCPS method cuts the calibration error --- the gap between an AI's expressed confidence and its actual accuracy --- by more than half on average.</p>
<p class="chinese-text">研究人员发现，他们的方法在预测法学硕士何时正确方面明显更好。与最强大的现有技术相比，CCPS 方法将校准误差（人工智能表达的置信度与其实际准确度之间的差距）平均减少了一半以上。</p>
</div>
<div class="paragraph-block">

</div>
<div class="paragraph-block">
<p class="english-text">"The CCPS method has profound clinical implications because it addresses the primary safety barrier for LLMs in medicine, which is their tendency to state errors with high confidence," said Kundan Thind, co-author on the paper and division head of radiation oncology physics with Henry Ford Cancer Institute. "This method improves an LLM's internal confidence calibration, enabling the model to reliably 'know when it doesn't know' and defer to human expert judgment."</p>
<p class="chinese-text">该论文的合著者、亨利·福特癌症研究所放射肿瘤物理部门负责人 Kundan Thind 表示：“CCPS 方法具有深远的临床意义，因为它解决了医学领域法学硕士的主要安全障碍，即他们倾向于高度自信地陈述错误。”“这种方法改进了法学硕士的内部置信度校准，使模型能够可靠地‘知道何时不知道’并遵循人类专家的判断。”</p>
</div>
<div class="paragraph-block">

</div>
<div class="paragraph-block">
<p class="english-text">This breakthrough has been tested on high-stakes examples in medical and financial question-answering, and its potential to enhance safety and trust in AI is vast.</p>
<p class="chinese-text">这一突破已经在医疗和金融问答领域的高风险示例上进行了测试，其增强人工智能安全性和信任的潜力是巨大的。</p>
</div>
<div class="paragraph-block">

</div>
<div class="paragraph-block">
<p class="english-text">This research was recently presented at the Conference on Empirical Methods in Natural Language Processing in China, where it was nominated for an Outstanding Paper Award --- a distinction placing the work in the top 0.4% of more than 8,000 submissions to the conference.</p>
<p class="chinese-text">这项研究最近在中国自然语言处理实证方法会议上发表，并被提名为杰出论文奖——这一殊荣使该工作在向会议提交的 8,000 多篇论文中跻身前 0.4%。</p>
</div>
<div class="paragraph-block">

</div>
<div class="paragraph-block">
<p class="english-text">Research funding was provided by the ++Henry Ford Health + Michigan State University Health Sciences Cancer Seed Funding Program++ and by the JPMorganChase Artificial Intelligence Research Faculty Research Award.</p>
<p class="chinese-text">研究经费由++亨利·福特健康+密歇根州立大学健康科学癌症种子资助计划++和摩根大通人工智能研究学院研究奖提供。</p>
</div>
<div class="paragraph-block">

</div>
<div class="paragraph-block">
<p class="english-text">Read in Cubox</p>
<p class="chinese-text">在 Cubox 中阅读</p>
</div>
<div class="paragraph-block">

</div>
</div>

    <!-- Translation Tooltip HTML -->
    <div class="translation-tooltip" id="translationTooltip" style="display: none; position: fixed; max-width: 400px; background-color: rgba(255, 255, 255, 0.98); border: 2px solid #5a3e2b; border-radius: 8px; padding: 15px; box-shadow: 0 4px 20px rgba(0,0,0,0.2); z-index: 1000; font-family: 'Microsoft YaHei', sans-serif;">
        <div class="tooltip-translation" style="color: #5a3e2b; font-size: 1rem; font-weight: 500; line-height: 1.6;">翻译中...</div>
    </div>
    <!-- Translation Script -->
    <script>
        // Article Translation Features
        // Features: Click-to-translate near cursor
        
        // Global variables
        let selectedParagraph = null;
        
        // Translation API (using free MyMemory API)
        const TRANSLATION_API = 'https://api.mymemory.translated.net/get';
        
        // DOM elements
        let translationTooltip;
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Get DOM elements
            translationTooltip = document.getElementById('translationTooltip');
            
            // Add click listener to close tooltip when clicking outside
            document.addEventListener('click', function(e) {
                // Check if click is outside tooltip and not on a selectable paragraph
                if (translationTooltip && 
                    !translationTooltip.contains(e.target) && 
                    !e.target.classList.contains('selectable')) {
                    hideTranslation();
                }
            });
            
            // Add selectable class to all English text paragraphs in articles
            const englishParagraphs = document.querySelectorAll('.english-text');
            englishParagraphs.forEach(paragraph => {
                // Only make English text selectable
                if (paragraph.textContent.trim()) {
                    paragraph.classList.add('selectable');
                    
                    // Add click listener for translation
                    paragraph.addEventListener('click', function(e) {
                        e.stopPropagation(); // Prevent document click from firing
                        handleParagraphClick(this, e);
                    });
                }
            });
        });
        
        // Handle paragraph click for translation
        function handleParagraphClick(element, event) {
            // Remove previous selection
            if (selectedParagraph) {
                selectedParagraph.classList.remove('selected');
            }
            
            // Mark as selected
            element.classList.add('selected');
            selectedParagraph = element;
            
            // Get the text to translate
            const textToTranslate = element.textContent;
            
            // Position tooltip near the click
            positionTooltip(event);
            
            // Show tooltip with loading state
            showTranslation(textToTranslate);
            
            // Fetch translation
            translateText(textToTranslate);
        }
        
        // Position tooltip near cursor but ensure it stays on screen
        function positionTooltip(event) {
            const tooltip = translationTooltip;
            const offset = 15; // Offset from cursor
            
            // Get viewport dimensions
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            // Initial position near cursor
            let left = event.pageX + offset;
            let top = event.pageY + offset;
            
            // Show tooltip temporarily to get its dimensions
            tooltip.style.display = 'block';
            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
            
            // Get tooltip dimensions
            const tooltipRect = tooltip.getBoundingClientRect();
            const tooltipWidth = tooltipRect.width;
            const tooltipHeight = tooltipRect.height;
            
            // Adjust if tooltip goes off right edge
            if (event.clientX + tooltipWidth + offset > viewportWidth) {
                left = event.pageX - tooltipWidth - offset;
            }
            
            // Adjust if tooltip goes off bottom edge
            if (event.clientY + tooltipHeight + offset > viewportHeight) {
                top = event.pageY - tooltipHeight - offset;
            }
            
            // Ensure tooltip doesn't go off left or top edges
            if (left < 10) left = 10;
            if (top < 80) top = 80; // Account for top nav
            
            // Set final position
            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
        }
        
        // Show translation tooltip
        function showTranslation(originalText) {
            const translationDiv = translationTooltip.querySelector('.tooltip-translation');
            
            // Show loading state
            translationDiv.textContent = '翻译中...';
            translationDiv.style.color = '#999';
            
            // Show tooltip
            translationTooltip.style.display = 'block';
        }
        
        // Hide translation tooltip
        function hideTranslation() {
            translationTooltip.style.display = 'none';
            if (selectedParagraph) {
                selectedParagraph.classList.remove('selected');
                selectedParagraph = null;
            }
        }
        
        // Translate text using free API
        async function translateText(text) {
            const translationDiv = translationTooltip.querySelector('.tooltip-translation');
            
            // Limit text length for API (MyMemory has a 500 character limit)
            const textToTranslate = text.length > 500 ? text.substring(0, 500) : text;
            
            // If text is too long, split it into chunks
            const maxChunkLength = 500; // MyMemory API limit
            
            if (text.length <= maxChunkLength) {
                // Short text - translate directly
                try {
                    const url = `${TRANSLATION_API}?q=${encodeURIComponent(text)}&langpair=en|zh-CN`;
                    const response = await fetch(url);
                    const data = await response.json();
                    
                    if (data.responseStatus === 200 && data.responseData) {
                        const translation = data.responseData.translatedText;
                        translationDiv.textContent = translation;
                        translationDiv.style.color = '#5a3e2b';
                    } else {
                        translationDiv.textContent = '翻译失败,请稍后重试';
                        translationDiv.style.color = '#d9534f';
                    }
                } catch (error) {
                    console.error('Translation error:', error);
                    translationDiv.textContent = '翻译服务暂时不可用';
                    translationDiv.style.color = '#d9534f';
                }
            } else {
                // Long text - split into chunks
                try {
                    // Split text into chunks of maxChunkLength, trying to break at sentence boundaries
                    const chunks = [];
                    let currentChunk = '';
                    
                    // First, try to split by sentence endings
                    const sentences = text.match(/[^.!?。！？]+[.!?。！？]*/g) || [text];
                    
                    for (const sentence of sentences) {
                        if ((currentChunk + sentence).length <= maxChunkLength) {
                            currentChunk += sentence;
                        } else {
                            if (currentChunk) {
                                chunks.push(currentChunk);
                            }
                            // If single sentence is too long, force split by maxChunkLength
                            if (sentence.length > maxChunkLength) {
                                for (let i = 0; i < sentence.length; i += maxChunkLength) {
                                    chunks.push(sentence.substring(i, i + maxChunkLength));
                                }
                                currentChunk = '';
                            } else {
                                currentChunk = sentence;
                            }
                        }
                    }
                    
                    if (currentChunk) {
                        chunks.push(currentChunk);
                    }
                    
                    // Translate each chunk
                    let fullTranslation = '';
                    for (let i = 0; i < chunks.length; i++) {
                        const chunk = chunks[i];
                        const url = `${TRANSLATION_API}?q=${encodeURIComponent(chunk)}&langpair=en|zh-CN`;
                        const response = await fetch(url);
                        const data = await response.json();
                        
                        if (data.responseStatus === 200 && data.responseData) {
                            fullTranslation += data.responseData.translatedText;
                            // Update display with progress
                            translationDiv.textContent = fullTranslation + ' [翻译中...]';
                        } else {
                            fullTranslation += '[翻译失败]';
                        }
                        
                        // Add small delay to avoid rate limiting
                        if (i < chunks.length - 1) {
                            await new Promise(resolve => setTimeout(resolve, 200));
                        }
                    }
                    
                    translationDiv.textContent = fullTranslation;
                    translationDiv.style.color = '#5a3e2b';
                } catch (error) {
                    console.error('Translation error:', error);
                    translationDiv.textContent = '翻译服务暂时不可用';
                    translationDiv.style.color = '#d9534f';
                }
            }
        }
        
        // Add CSS for selected state
        const style = document.createElement('style');
        style.textContent = `
            .selectable {
                cursor: pointer;
                transition: background-color 0.2s ease;
                padding: 2px 4px;
                border-radius: 3px;
            }
            
            .selectable:hover {
                background-color: rgba(212, 167, 106, 0.2);
            }
            
            .selectable.selected {
                background-color: rgba(212, 167, 106, 0.4);
            }
            
            .translation-tooltip {
                animation: fadeIn 0.2s ease;
            }
            
            @keyframes fadeIn {
                from {
                    opacity: 0;
                    transform: translateY(-5px);
                }
                to {
                    opacity: 1;
                    transform: translateY(0);
                }
            }
        `;
        document.head.appendChild(style);
    </script>
    </body>
</html>