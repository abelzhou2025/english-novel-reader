<!DOCTYPE html>

<html lang="zh">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>AI code you can trust - English Novel Reader</title>
<link href="../styles.css" rel="stylesheet"/>
<style>
        body {
            font-family: Georgia, serif;
            background-color: #f9f7f4;
            margin: 0;
            padding: 0;
        }
        
        .article-content {
            max-width: 900px;
            margin: 100px auto 50px;
            padding: 40px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        .back-btn {
            display: inline-block;
            background-color: #5a3e2b;
            color: #fff;
            padding: 10px 20px;
            border-radius: 6px;
            text-decoration: none;
            font-family: 'Microsoft YaHei', sans-serif;
            font-size: 0.95rem;
            transition: all 0.3s ease;
            margin-bottom: 30px;
        }
        
        .back-btn:hover {
            background-color: #7a5c42;
            transform: translateY(-2px);
        }
        
        .article-title {
            font-family: Georgia, serif;
            font-size: 2rem;
            color: #2c2c2c;
            margin-bottom: 30px;
            line-height: 1.3;
            font-weight: 600;
        }
        
        .article-section {
            margin-bottom: 30px;
        }
        
        .section-heading {
            font-family: Georgia, serif;
            font-size: 1.5rem;
            color: #3a3a3a;
            margin-top: 35px;
            margin-bottom: 20px;
            font-weight: 600;
            line-height: 1.4;
        }
        
        .section-subheading {
            font-family: Georgia, serif;
            font-size: 1.2rem;
            color: #4a4a4a;
            margin-top: 25px;
            margin-bottom: 15px;
            font-weight: 600;
            line-height: 1.4;
        }
        
        .paragraph-block {
            margin-bottom: 25px;
        }
        
        .english-text {
            font-family: Georgia, serif;
            font-size: 1.1rem;
            color: #2c2c2c;
            line-height: 1.8;
            margin-bottom: 12px;
        }
        
        .chinese-text {
            font-family: 'Microsoft YaHei', 'SimHei', sans-serif;
            font-size: 1rem;
            color: #666;
            line-height: 1.8;
            padding-left: 20px;
            border-left: 3px solid #d4a76a;
            opacity: 0.7;
        }
        
        @media (max-width: 768px) {
            .article-content {
                margin: 80px 15px 30px;
                padding: 25px;
            }
            
            .article-title {
                font-size: 1.6rem;
            }
            
            .section-heading {
                font-size: 1.3rem;
            }
            
            .english-text {
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
<!-- Top Navigation -->
<nav class="top-nav">
<ul>
<li><a href="../index.html">首页</a></li>
<li><a href="../novels.html">小说</a></li>
<li><a class="active" href="../webnovels.html">网文</a></li>
    <li><a href="../news.html">新闻</a></li>
    <li><a href="../about.html">关于我</a></li>
</ul>
</nav>
<div class="article-content">
<a class="back-btn" href="../webnovels.html">← 返回网文列表</a>
<h1 class="article-title">AI code you can trust</h1>
<div class="paragraph-block">
<p class="english-text">www.fastcompany.com Fast Company Custom Studio</p>
<p class="chinese-text">www.fastcompany.com Fast Company 定制工作室</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
<div class="paragraph-block">
<p class="english-text">AI can help software developers build applications faster than ever, but this creates a new problem. How do developers verify that the code being written with AI is reliable, maintainable, and secure? Software company Sonar helps developers verify their code---even when it is written by AI---allowing them to build better software, faster.</p>
<p class="chinese-text">人工智能可以帮助软件开发人员比以往更快地构建应用程序，但这会带来一个新问题。开发人员如何验证用人工智能编写的代码是否可靠、可维护且安全？软件公司 Sonar 帮助开发人员验证他们的代码（即使代码是由人工智能编写的），使他们能够更快地构建更好的软件。</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
<div class="paragraph-block">
<p class="english-text">"The amount of code being written by AI is exploding," says Tariq Shaukat, Sonar's CEO. "It's improving productivity, it's improving prototyping, and it's improving the quality of the work that's getting done. The main thing it lacks is trustworthiness. You don't really know what the models are writing."</p>
<p class="chinese-text">Sonar 首席执行官塔里克·肖卡特 (Tariq Shaukat) 表示：“人工智能编写的代码量正在呈爆炸式增长。”“它提高了生产力，改进了原型设计，提高了已完成工作的质量。它缺乏的主要是可信度。你并不真正知道模型在写什么。”</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
<div class="paragraph-block">
<p class="english-text">Sonar's ability to provide guardrails around code quality that make AI coding safer and more effective has earned the company a spot on Fast Company's list of Next Big Things in Tech for 2025.</p>
<p class="chinese-text">Sonar 能够提供代码质量保障，使 AI 编码更安全、更有效，这为该公司赢得了 Fast Company 2025 年科技领域下一件大事的名单。</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
<h3 class="section-subheading">MAINTAINING STANDARDS</h3>
<div class="paragraph-block">
<p class="english-text">Coding errors can create security vulnerabilities, crash systems, expose sensitive information, disrupt services, and damage a company's reputation. Sonar's flagship product, SonarQube, is designed to keep that from happening. Not only does it identify bugs, it calls out security risks, duplication, poor structure, and violations of coding standards. It also integrates with a wide range of developer tools, allowing users to get actionable information to improve their code directly in their workflows.</p>
<p class="chinese-text">编码错误可能会造成安全漏洞、系统崩溃、暴露敏感信息、扰乱服务并损害公司声誉。Sonar 的旗舰产品 SonarQube 旨在防止这种情况发生。它不仅可以识别错误，还可以指出安全风险、重复、结构不良和违反编码标准的情况。它还与广泛的开发人员工具集成，允许用户获取可操作的信息，以直接在工作流程中改进代码。</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
<div class="paragraph-block">
<p class="english-text">"AI technology is amazing, but it is not magic," Shaukat says. "It's not perfect, and it's not going to be perfect. You need code verification that's rigorous and mandatory."</p>
<p class="chinese-text">“人工智能技术令人惊叹，但它并不是魔法，”肖卡特说。“它并不完美，也不会完美。你需要严格且强制性的代码验证。”</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
<div class="paragraph-block">
<p class="english-text">Today, Sonar's tools analyze more than 750 billion lines of code a day, catching reliability issues, security issues, and maintainability issues along the way. The process begins with customers setting minimum standards for code quality and accuracy, based on factors such as regulatory requirements and how the application will be used. For example, customers may set accuracy requirements higher for functions like bank transactions than they would for an informational website. Sonar's technology then acts as a gatekeeper to uphold that standard, keeping flawed code from being incorporated into software.</p>
<p class="chinese-text">如今，Sonar 的工具每天分析超过 7500 亿行代码，一路捕获可靠性问题、安全问题和可维护性问题。该过程首先由客户根据监管要求和应用程序的使用方式等因素设定代码质量和准确性的最低标准。例如，客户可能会对银行交易等功能设置比信息网站更高的准确性要求。然后，Sonar 的技术充当维护该标准的看门人，防止有缺陷的代码被合并到软件中。</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
<div class="paragraph-block">
<p class="english-text">"Our products analyze the code as it's being written by the AI before it's merged with your code base," Shaukat said. "It doesn't actually hit your code base until our products check it."</p>
<p class="chinese-text">“我们的产品会在人工智能编写代码时对其进行分析，然后再将其与您的代码库合并，”Shaukat 说。“在我们的产品检查之前，它实际上不会触及您的代码库。”</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
<h3 class="section-subheading">MAKING THINGS RIGHT</h3>
<div class="paragraph-block">
<p class="english-text">Sonar does more than just help developers identify problems. Its AI CodeFix technology recommends how to automatically repair a specific bug or vulnerability and why it is the right thing to do in the context of the overall software. If a developer agrees with the recommendation, they can simply choose to accept the suggested fix. The technology leverages Sonar's code analyzer to detect issues; an LLM then generates the highly contextual, accurate fix suggestion.</p>
<p class="chinese-text">Sonar 的作用不仅仅是帮助开发人员发现问题。其 AI CodeFix 技术建议如何自动修复特定错误或漏洞，以及为什么在整个软件的背景下这样做是正确的。如果开发人员同意该建议，他们只需选择接受建议的修复即可。该技术利用 Sonar 的代码分析器来检测问题；然后，法学硕士会生成高度相关的、准确的修复建议。</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
<div class="paragraph-block">
<p class="english-text">Sonar is also beta testing for a new offering that uses AI agents to automatically repair code. These agents autonomously perform complex multistep tasks, with the ability to analyze a software program's structure and infer developer intent to understand the broader context of how the code is being used. Developers still have final say, but Sonar's technology largely frees them from tedious repair work so they can focus instead on high-level design and innovation.</p>
<p class="chinese-text">Sonar 还在对一项新产品进行 Beta 测试，该产品使用人工智能代理自动修复代码。这些代理自主执行复杂的多步骤任务，能够分析软件程序的结构并推断开发人员意图了解代码如何使用的更广泛上下文。开发人员仍然拥有最终决定权，但 Sonar 的技术在很大程度上将他们从繁琐的修复工作中解放出来，这样他们就可以专注于高级设计和创新。</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
<div class="paragraph-block">
<p class="english-text">"Fixing things that broke is not the fun part of a developer's job," Shaukat says. "Virtually every development team has a long list of projects they can't get to because they just don't have time. Our goal is to give them that time back."</p>
<p class="chinese-text">“修复损坏的东西并不是开发人员工作中有趣的部分，”Shaukat 说。“几乎每个开发团队都有一长串他们无法完成的项目清单，因为他们只是没有时间。我们的目标是给他们时间。”</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
<div class="paragraph-block">
<p class="english-text">Read in Cubox</p>
<p class="chinese-text">在 Cubox 中阅读</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
</div>

    <!-- Translation Tooltip HTML -->
    <div class="translation-tooltip" id="translationTooltip" style="display: none; position: fixed; max-width: 400px; background-color: rgba(255, 255, 255, 0.98); border: 2px solid #5a3e2b; border-radius: 8px; padding: 15px; box-shadow: 0 4px 20px rgba(0,0,0,0.2); z-index: 1000; font-family: 'Microsoft YaHei', sans-serif;">
        <div class="tooltip-translation" style="color: #5a3e2b; font-size: 1rem; font-weight: 500; line-height: 1.6;">翻译中...</div>
    </div>
    <!-- Translation Script -->
    <script>
        // Article Translation Features
        // Features: Click-to-translate near cursor
        
        // Global variables
        let selectedParagraph = null;
        
        // Translation API (using free MyMemory API)
        const TRANSLATION_API = 'https://api.mymemory.translated.net/get';
        
        // DOM elements
        let translationTooltip;
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Get DOM elements
            translationTooltip = document.getElementById('translationTooltip');
            
            // Add click listener to close tooltip when clicking outside
            document.addEventListener('click', function(e) {
                // Check if click is outside tooltip and not on a selectable paragraph
                if (translationTooltip && 
                    !translationTooltip.contains(e.target) && 
                    !e.target.classList.contains('selectable')) {
                    hideTranslation();
                }
            });
            
            // Add selectable class to all English text paragraphs in articles
            const englishParagraphs = document.querySelectorAll('.english-text');
            englishParagraphs.forEach(paragraph => {
                // Only make English text selectable
                if (paragraph.textContent.trim()) {
                    paragraph.classList.add('selectable');
                    
                    // Add click listener for translation
                    paragraph.addEventListener('click', function(e) {
                        e.stopPropagation(); // Prevent document click from firing
                        handleParagraphClick(this, e);
                    });
                }
            });
        });
        
        // Handle paragraph click for translation
        function handleParagraphClick(element, event) {
            // Remove previous selection
            if (selectedParagraph) {
                selectedParagraph.classList.remove('selected');
            }
            
            // Mark as selected
            element.classList.add('selected');
            selectedParagraph = element;
            
            // Get the text to translate
            const textToTranslate = element.textContent;
            
            // Position tooltip near the click
            positionTooltip(event);
            
            // Show tooltip with loading state
            showTranslation(textToTranslate);
            
            // Fetch translation
            translateText(textToTranslate);
        }
        
        // Position tooltip near cursor but ensure it stays on screen
        function positionTooltip(event) {
            const tooltip = translationTooltip;
            const offset = 15; // Offset from cursor
            
            // Get viewport dimensions
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            // Initial position near cursor
            let left = event.pageX + offset;
            let top = event.pageY + offset;
            
            // Show tooltip temporarily to get its dimensions
            tooltip.style.display = 'block';
            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
            
            // Get tooltip dimensions
            const tooltipRect = tooltip.getBoundingClientRect();
            const tooltipWidth = tooltipRect.width;
            const tooltipHeight = tooltipRect.height;
            
            // Adjust if tooltip goes off right edge
            if (event.clientX + tooltipWidth + offset > viewportWidth) {
                left = event.pageX - tooltipWidth - offset;
            }
            
            // Adjust if tooltip goes off bottom edge
            if (event.clientY + tooltipHeight + offset > viewportHeight) {
                top = event.pageY - tooltipHeight - offset;
            }
            
            // Ensure tooltip doesn't go off left or top edges
            if (left < 10) left = 10;
            if (top < 80) top = 80; // Account for top nav
            
            // Set final position
            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
        }
        
        // Show translation tooltip
        function showTranslation(originalText) {
            const translationDiv = translationTooltip.querySelector('.tooltip-translation');
            
            // Show loading state
            translationDiv.textContent = '翻译中...';
            translationDiv.style.color = '#999';
            
            // Show tooltip
            translationTooltip.style.display = 'block';
        }
        
        // Hide translation tooltip
        function hideTranslation() {
            translationTooltip.style.display = 'none';
            if (selectedParagraph) {
                selectedParagraph.classList.remove('selected');
                selectedParagraph = null;
            }
        }
        
        // Translate text using free API
        async function translateText(text) {
            const translationDiv = translationTooltip.querySelector('.tooltip-translation');
            
            // Limit text length for API (MyMemory has a 500 character limit)
            const textToTranslate = text.length > 500 ? text.substring(0, 500) : text;
            
            // If text is too long, split it into chunks
            const maxChunkLength = 500; // MyMemory API limit
            
            if (text.length <= maxChunkLength) {
                // Short text - translate directly
                try {
                    const url = `${TRANSLATION_API}?q=${encodeURIComponent(text)}&langpair=en|zh-CN`;
                    const response = await fetch(url);
                    const data = await response.json();
                    
                    if (data.responseStatus === 200 && data.responseData) {
                        const translation = data.responseData.translatedText;
                        translationDiv.textContent = translation;
                        translationDiv.style.color = '#5a3e2b';
                    } else {
                        translationDiv.textContent = '翻译失败,请稍后重试';
                        translationDiv.style.color = '#d9534f';
                    }
                } catch (error) {
                    console.error('Translation error:', error);
                    translationDiv.textContent = '翻译服务暂时不可用';
                    translationDiv.style.color = '#d9534f';
                }
            } else {
                // Long text - split into chunks
                try {
                    // Split text into chunks of maxChunkLength, trying to break at sentence boundaries
                    const chunks = [];
                    let currentChunk = '';
                    
                    // First, try to split by sentence endings
                    const sentences = text.match(/[^.!?。！？]+[.!?。！？]*/g) || [text];
                    
                    for (const sentence of sentences) {
                        if ((currentChunk + sentence).length <= maxChunkLength) {
                            currentChunk += sentence;
                        } else {
                            if (currentChunk) {
                                chunks.push(currentChunk);
                            }
                            // If single sentence is too long, force split by maxChunkLength
                            if (sentence.length > maxChunkLength) {
                                for (let i = 0; i < sentence.length; i += maxChunkLength) {
                                    chunks.push(sentence.substring(i, i + maxChunkLength));
                                }
                                currentChunk = '';
                            } else {
                                currentChunk = sentence;
                            }
                        }
                    }
                    
                    if (currentChunk) {
                        chunks.push(currentChunk);
                    }
                    
                    // Translate each chunk
                    let fullTranslation = '';
                    for (let i = 0; i < chunks.length; i++) {
                        const chunk = chunks[i];
                        const url = `${TRANSLATION_API}?q=${encodeURIComponent(chunk)}&langpair=en|zh-CN`;
                        const response = await fetch(url);
                        const data = await response.json();
                        
                        if (data.responseStatus === 200 && data.responseData) {
                            fullTranslation += data.responseData.translatedText;
                            // Update display with progress
                            translationDiv.textContent = fullTranslation + ' [翻译中...]';
                        } else {
                            fullTranslation += '[翻译失败]';
                        }
                        
                        // Add small delay to avoid rate limiting
                        if (i < chunks.length - 1) {
                            await new Promise(resolve => setTimeout(resolve, 200));
                        }
                    }
                    
                    translationDiv.textContent = fullTranslation;
                    translationDiv.style.color = '#5a3e2b';
                } catch (error) {
                    console.error('Translation error:', error);
                    translationDiv.textContent = '翻译服务暂时不可用';
                    translationDiv.style.color = '#d9534f';
                }
            }
        }
        
        // Add CSS for selected state
        const style = document.createElement('style');
        style.textContent = `
            .selectable {
                cursor: pointer;
                transition: background-color 0.2s ease;
                padding: 2px 4px;
                border-radius: 3px;
            }
            
            .selectable:hover {
                background-color: rgba(212, 167, 106, 0.2);
            }
            
            .selectable.selected {
                background-color: rgba(212, 167, 106, 0.4);
            }
            
            .translation-tooltip {
                animation: fadeIn 0.2s ease;
            }
            
            @keyframes fadeIn {
                from {
                    opacity: 0;
                    transform: translateY(-5px);
                }
                to {
                    opacity: 1;
                    transform: translateY(0);
                }
            }
        `;
        document.head.appendChild(style);
    </script>
    </body>
</html>