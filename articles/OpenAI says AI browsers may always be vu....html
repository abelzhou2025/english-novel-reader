<!DOCTYPE html>

<html lang="zh">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>OpenAI says AI browsers may always be vulnerable to prompt injection attacks - English Novel Reader</title>
<link href="../styles.css" rel="stylesheet"/>
<style>
        body {
            font-family: Georgia, serif;
            background-color: #f9f7f4;
            margin: 0;
            padding: 0;
        }
        
        .article-content {
            max-width: 900px;
            margin: 100px auto 50px;
            padding: 40px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        .back-btn {
            display: inline-block;
            background-color: #5a3e2b;
            color: #fff;
            padding: 10px 20px;
            border-radius: 6px;
            text-decoration: none;
            font-family: 'Microsoft YaHei', sans-serif;
            font-size: 0.95rem;
            transition: all 0.3s ease;
            margin-bottom: 30px;
        }
        
        .back-btn:hover {
            background-color: #7a5c42;
            transform: translateY(-2px);
        }
        
        .article-title {
            font-family: Georgia, serif;
            font-size: 2rem;
            color: #2c2c2c;
            margin-bottom: 30px;
            line-height: 1.3;
            font-weight: 600;
        }
        
        .article-section {
            margin-bottom: 30px;
        }
        
        .section-heading {
            font-family: Georgia, serif;
            font-size: 1.5rem;
            color: #3a3a3a;
            margin-top: 35px;
            margin-bottom: 20px;
            font-weight: 600;
            line-height: 1.4;
        }
        
        .section-subheading {
            font-family: Georgia, serif;
            font-size: 1.2rem;
            color: #4a4a4a;
            margin-top: 25px;
            margin-bottom: 15px;
            font-weight: 600;
            line-height: 1.4;
        }
        
        .paragraph-block {
            margin-bottom: 25px;
        }
        
        .english-text {
            font-family: Georgia, serif;
            font-size: 1.1rem;
            color: #2c2c2c;
            line-height: 1.8;
            margin-bottom: 12px;
        }
        
        .chinese-text {
            font-family: 'Microsoft YaHei', 'SimHei', sans-serif;
            font-size: 1rem;
            color: #666;
            line-height: 1.8;
            padding-left: 20px;
            border-left: 3px solid #d4a76a;
            opacity: 0.7;
        }
        
        @media (max-width: 768px) {
            .article-content {
                margin: 80px 15px 30px;
                padding: 25px;
            }
            
            .article-title {
                font-size: 1.6rem;
            }
            
            .section-heading {
                font-size: 1.3rem;
            }
            
            .english-text {
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
<!-- Top Navigation -->
<nav class="top-nav">
<ul>
<li><a href="../index.html">首页</a></li>
<li><a href="../novels.html">小说</a></li>
<li><a class="active" href="../webnovels.html">网文</a></li>
    <li><a href="../news.html">新闻</a></li>
    <li><a href="../about.html">关于我</a></li>
</ul>
</nav>
<div class="article-content">
<a class="back-btn" href="../webnovels.html">← 返回网文列表</a>
<h1 class="article-title">OpenAI says AI browsers may always be vulnerable to prompt injection attacks</h1>
<div class="paragraph-block">
<p class="english-text">techcrunch.com Rebecca Bellan</p>
<p class="chinese-text">techcrunch.com 丽贝卡·贝兰</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
<div class="paragraph-block">
<p class="english-text">Even as OpenAI works to harden its Atlas AI browser against cyberattacks, the company admits that prompt injections, a type of attack that manipulates AI agents to follow malicious instructions often hidden in web pages or emails, is a risk that's not going away anytime soon --- raising questions about how safely AI agents can operate on the open web.</p>
<p class="chinese-text">尽管 OpenAI 致力于强化其 Atlas AI 浏览器以抵御网络攻击，但该公司承认，即时注入（一种操纵 AI 代理遵循通常隐藏在网页或电子邮件中的恶意指令的攻击）是一种不会很快消失的风险，引发了人们对 AI 代理在开放网络上运行的安全性的质疑。</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
<div class="paragraph-block">
<p class="english-text">"Prompt injection, much like scams and social engineering on the web, is unlikely to ever be fully 'solved,'" OpenAI wrote in a Monday blog post detailing how the firm is beefing up Atlas' armor to combat the unceasing attacks. The company conceded that "agent mode" in ChatGPT Atlas "expands the security threat surface."</p>
<p class="chinese-text">OpenAI 在周一的博客文章中写道：“即时注入，就像网络上的诈骗和社会工程一样，不太可能被完全‘解决’。”该文章详细介绍了该公司如何增强 Atlas 的防御能力，以应对不断发生的攻击。该公司承认 ChatGPT Atlas 中的“代理模式”“扩大了安全威胁面”。</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
<div class="paragraph-block">
<p class="english-text">OpenAI launched its ChatGPT Atlas browser in October, and security researchers rushed to publish their demos, showing it was possible to write a few words in Google Docs that were capable of changing the underlying browser's behavior. That same day, Brave published a blog post explaining that indirect prompt injection is a systematic challenge for AI-powered browsers, including Perplexity's Comet.</p>
<p class="chinese-text">OpenAI 在 10 月份推出了 ChatGPT Atlas 浏览器，安全研究人员纷纷发布他们的演示，表明可以在 Google Docs 中编写一些单词来改变底层浏览器的行为。同一天，Brave 发表了一篇博文，解释间接提示注入对于人工智能浏览器（包括 Perplexity 的 Comet）来说是一个系统性挑战。</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
<div class="paragraph-block">
<p class="english-text">OpenAI isn't alone in recognizing that prompt-based injections aren't going away. The U.K.'s National Cyber Security Centre earlier this month warned that prompt injection attacks against generative AI applications "may never be totally mitigated," putting websites at risk of falling victim to data breaches. The U.K. government agency advised cyber professionals to reduce the risk and impact of prompt injections, rather than think the attacks can be "stopped."</p>
<p class="chinese-text">OpenAI 并不是唯一一家认识到基于提示的注入不会消失的公司。英国国家网络安全中心本月早些时候警告称，针对生成型人工智能应用程序的即时注入攻击“可能永远无法完全缓解”，从而使网站面临成为数据泄露受害者的风险。英国政府机构建议网络专业人士减少即时注入的风险和影响，而不是认为攻击可以“阻止”。</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
<div class="paragraph-block">
<p class="english-text">For OpenAI's part, the company said: "We view prompt injection as a long-term AI security challenge, and we'll need to continuously strengthen our defenses against it."</p>
<p class="chinese-text">就 OpenAI 而言，该公司表示：“我们认为即时注入是一项长期的人工智能安全挑战，我们需要不断加强针对它的防御。”</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
<div class="paragraph-block">
<p class="english-text">The company's answer to this Sisyphean task? A proactive, rapid-response cycle that the firm says is showing early promise in helping discover novel attack strategies internally before they are exploited "in the wild."</p>
<p class="chinese-text">公司对这个西西弗斯任务的答案是什么？该公司表示，主动、快速响应的循环正在显示出早期的前景，有助于在新的攻击策略被“野外”利用之前在内部发现它们。</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
<div class="paragraph-block">
<p class="english-text">That's not entirely different from what rivals like Anthropic and Google have been saying: that to fight against the persistent risk of prompt-based attacks, defenses must be layered and continuously stress-tested. Google's recent work, for example, focuses on architectural and policy-level controls for agentic systems.</p>
<p class="chinese-text">这与 Anthropic 和 Google 等竞争对手所说的并没有完全不同：为了应对基于即时的攻击的持续风险，防御必须分层并持续进行压力测试。例如，谷歌最近的工作重点是代理系统的架构和策略级控制。</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
<div class="paragraph-block">
<p class="english-text">But where OpenAI is taking a different tact is with its "LLM-based automated attacker." This attacker is basically a bot that OpenAI trained, using reinforcement learning, to play the role of a hacker that looks for ways to sneak malicious instructions to an AI agent.</p>
<p class="chinese-text">但 OpenAI 采取了不同的策略，即“基于 LLM 的自动攻击者”。该攻击者基本上是 OpenAI 使用强化学习训练的机器人，扮演黑客的角色，寻找向 AI 代理偷偷恶意指令的方法。</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
<div class="paragraph-block">
<p class="english-text">The bot can test the attack in simulation before using it for real, and the simulator shows how the target AI would think and what actions it would take if it saw the attack. The bot can then study that response, tweak the attack, and try again and again. That insight into the target AI's internal reasoning is something outsiders don't have access to, so, in theory, OpenAI's bot should be able to find flaws faster than a real-world attacker would.</p>
<p class="chinese-text">机器人可以在实际使用攻击之前在模拟中测试攻击，模拟器会显示目标人工智能会如何思考，以及如果它看到攻击会采取什么行动。然后，机器人可以研究该响应，调整攻击，并一次又一次地尝试。外部人员无法洞察目标 AI 的内部推理，因此从理论上讲，OpenAI 的机器人应该能够比现实世界的攻击者更快地发现缺陷。</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
<div class="paragraph-block">
<p class="english-text">It's a common tactic in AI safety testing: build an agent to find the edge cases and test against them rapidly in simulation.</p>
<p class="chinese-text">这是人工智能安全测试中的常见策略：构建一个代理来查找边缘情况并在模拟中快速对其进行测试。</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
<div class="paragraph-block">
<p class="english-text">"Our [reinforcement learning]-trained attacker can steer an agent into executing sophisticated, long-horizon harmful workflows that unfold over tens (or even hundreds) of steps," wrote OpenAI. "We also observed novel attack strategies that did not appear in our human red teaming campaign or external reports."OpenAI</p>
<p class="chinese-text">OpenAI 写道：“我们经过[强化学习]训练的攻击者可以引导代理执行复杂的、长期有害的工作流程，这些工作流程会展开数十（甚至数百）个步骤。”“我们还观察到了新的攻击策略，这些策略没有出现在我们的人类红队活动或外部报告中。”
图片来源：OpenAI</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
<div class="paragraph-block">
<p class="english-text">In a demo (pictured in part above), OpenAI showed how its automated attacker slipped a malicious email into a user's inbox. When the AI agent later scanned the inbox, it followed the hidden instructions in the email and sent a resignation message instead of drafting an out-of-office reply. But following the security update, "agent mode" was able to successfully detect the prompt injection attempt and flag it to the user, according to the company.</p>
<p class="chinese-text">在演示中（如上图所示），OpenAI 展示了其自动攻击者如何将恶意电子邮件放入用户的收件箱中。当人工智能代理后来扫描收件箱时，它按照电子邮件中的隐藏说明发送了辞职消息，而不是起草外出回复。但据该公司称，在安全更新之后，“代理模式”能够成功检测到提示注入尝试并将其标记给用户。</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
<div class="paragraph-block">
<p class="english-text">The company says that while prompt injection is hard to secure against in a foolproof way, it's leaning on large-scale testing and faster patch cycles to harden its systems before they show up in real-world attacks.</p>
<p class="chinese-text">该公司表示，虽然很难以万无一失的方式防范即时注入，但它依靠大规模测试和更快的补丁周期来强化其系统，防止它们出现在现实世界的攻击中。</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
<div class="paragraph-block">
<p class="english-text">An OpenAI spokesperson declined to share whether the update to Atlas' security has resulted in a measurable reduction in successful injections, but says the firm has been working with third parties to harden Atlas against prompt injection since before launch.</p>
<p class="chinese-text">OpenAI 发言人拒绝透露 Atlas 安全更新是否导致成功注入次数明显减少，但表示该公司自发布前就一直在与第三方合作，以加强 Atlas 的安全性，以防止快速注入。</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
<div class="paragraph-block">
<p class="english-text">Rami McCarthy, principal security researcher at cybersecurity firm Wiz, says that reinforcement learning is one way to continuously adapt to attacker behavior, but it's only part of the picture.</p>
<p class="chinese-text">网络安全公司 Wiz 的首席安全研究员 Rami McCarthy 表示，强化学习是不断适应攻击者行为的一种方法，但这只是整体情况的一部分。</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
<div class="paragraph-block">
<p class="english-text">"A useful way to reason about risk in AI systems is autonomy multiplied by access," McCarthy told TechCrunch.</p>
<p class="chinese-text">“推断人工智能系统风险的一个有用方法是自主权乘以访问权，”麦卡锡告诉 TechCrunch。</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
<div class="paragraph-block">
<p class="english-text">"Agentic browsers tend to sit in a challenging part of that space: moderate autonomy combined with very high access," said McCarthy. "Many current recommendations reflect that trade-off. Limiting logged-in access primarily reduces exposure, while requiring review of confirmation requests constrains autonomy."</p>
<p class="chinese-text">“代理浏览器往往处于该领域具有挑战性的部分：适度的自治与非常高的访问权限相结合，”麦卡锡说。“当前的许多建议都反映了这种权衡。限制登录访问主要是减少暴露，而要求审查确认请求则限制了自主权。”</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
<div class="paragraph-block">
<p class="english-text">Those are two of OpenAI's recommendations for users to reduce their own risk, and a spokesperson said Atlas is also trained to get user confirmation before sending messages or making payments. OpenAI also suggests that users give agents specific instructions, rather than providing them access to your inbox and telling them to "take whatever action is needed."</p>
<p class="chinese-text">这是 OpenAI 为用户降低自身风险而提出的两项建议，一位发言人表示，Atlas 还接受过培训，可以在发送消息或付款之前获得用户确认。OpenAI 还建议用户向代理提供具体指示，而不是让他们访问您的收件箱并告诉他们“采取任何需要的行动”。</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
<div class="paragraph-block">
<p class="english-text">"Wide latitude makes it easier for hidden or malicious content to influence the agent, even when safeguards are in place," per OpenAI.</p>
<p class="chinese-text">OpenAI 表示：“即使采取了防护措施，宽泛的自由度也使得隐藏或恶意内容更容易影响代理。”</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
<div class="paragraph-block">
<p class="english-text">While OpenAI says protecting Atlas users against prompt injections is a top priority, McCarthy invites some skepticism as to the return on investment for risk-prone browsers.</p>
<p class="chinese-text">虽然 OpenAI 表示保护 Atlas 用户免受即时注入是首要任务，但麦卡锡对高风险浏览器的投资回报提出了一些怀疑。</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
<div class="paragraph-block">
<p class="english-text">"For most everyday use cases, agentic browsers don't yet deliver enough value to justify their current risk profile," McCarthy told TechCrunch. "The risk is high given their access to sensitive data like email and payment information, even though that access is also what makes them powerful. That balance will evolve, but today the trade-offs are still very real."</p>
<p class="chinese-text">“对于大多数日常使用案例，代理浏览器尚未提供足够的价值来证明其当前的风险状况，”麦卡锡告诉 TechCrunch。“鉴于他们能够访问电子邮件和支付信息等敏感数据，风险很高，尽管这种访问也使他们变得强大。这种平衡将会演变，但今天的权衡仍然非常现实。”</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
<div class="paragraph-block">
<p class="english-text">Read in Cubox</p>
<p class="chinese-text">在 Cubox 中阅读</p>
</div>
<div class="paragraph-block">

<p class="chinese-text">[翻译占位 - 翻译占位符]</p>
</div>
</div>

    <!-- Translation Tooltip HTML -->
    <div class="translation-tooltip" id="translationTooltip" style="display: none; position: fixed; max-width: 400px; background-color: rgba(255, 255, 255, 0.98); border: 2px solid #5a3e2b; border-radius: 8px; padding: 15px; box-shadow: 0 4px 20px rgba(0,0,0,0.2); z-index: 1000; font-family: 'Microsoft YaHei', sans-serif;">
        <div class="tooltip-translation" style="color: #5a3e2b; font-size: 1rem; font-weight: 500; line-height: 1.6;">翻译中...</div>
    </div>
    <!-- Translation Script -->
    <script>
        // Article Translation Features
        // Features: Click-to-translate near cursor
        
        // Global variables
        let selectedParagraph = null;
        
        // Translation API (using free MyMemory API)
        const TRANSLATION_API = 'https://api.mymemory.translated.net/get';
        
        // DOM elements
        let translationTooltip;
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Get DOM elements
            translationTooltip = document.getElementById('translationTooltip');
            
            // Add click listener to close tooltip when clicking outside
            document.addEventListener('click', function(e) {
                // Check if click is outside tooltip and not on a selectable paragraph
                if (translationTooltip && 
                    !translationTooltip.contains(e.target) && 
                    !e.target.classList.contains('selectable')) {
                    hideTranslation();
                }
            });
            
            // Add selectable class to all English text paragraphs in articles
            const englishParagraphs = document.querySelectorAll('.english-text');
            englishParagraphs.forEach(paragraph => {
                // Only make English text selectable
                if (paragraph.textContent.trim()) {
                    paragraph.classList.add('selectable');
                    
                    // Add click listener for translation
                    paragraph.addEventListener('click', function(e) {
                        e.stopPropagation(); // Prevent document click from firing
                        handleParagraphClick(this, e);
                    });
                }
            });
        });
        
        // Handle paragraph click for translation
        function handleParagraphClick(element, event) {
            // Remove previous selection
            if (selectedParagraph) {
                selectedParagraph.classList.remove('selected');
            }
            
            // Mark as selected
            element.classList.add('selected');
            selectedParagraph = element;
            
            // Get the text to translate
            const textToTranslate = element.textContent;
            
            // Position tooltip near the click
            positionTooltip(event);
            
            // Show tooltip with loading state
            showTranslation(textToTranslate);
            
            // Fetch translation
            translateText(textToTranslate);
        }
        
        // Position tooltip near cursor but ensure it stays on screen
        function positionTooltip(event) {
            const tooltip = translationTooltip;
            const offset = 15; // Offset from cursor
            
            // Get viewport dimensions
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            // Initial position near cursor
            let left = event.pageX + offset;
            let top = event.pageY + offset;
            
            // Show tooltip temporarily to get its dimensions
            tooltip.style.display = 'block';
            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
            
            // Get tooltip dimensions
            const tooltipRect = tooltip.getBoundingClientRect();
            const tooltipWidth = tooltipRect.width;
            const tooltipHeight = tooltipRect.height;
            
            // Adjust if tooltip goes off right edge
            if (event.clientX + tooltipWidth + offset > viewportWidth) {
                left = event.pageX - tooltipWidth - offset;
            }
            
            // Adjust if tooltip goes off bottom edge
            if (event.clientY + tooltipHeight + offset > viewportHeight) {
                top = event.pageY - tooltipHeight - offset;
            }
            
            // Ensure tooltip doesn't go off left or top edges
            if (left < 10) left = 10;
            if (top < 80) top = 80; // Account for top nav
            
            // Set final position
            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
        }
        
        // Show translation tooltip
        function showTranslation(originalText) {
            const translationDiv = translationTooltip.querySelector('.tooltip-translation');
            
            // Show loading state
            translationDiv.textContent = '翻译中...';
            translationDiv.style.color = '#999';
            
            // Show tooltip
            translationTooltip.style.display = 'block';
        }
        
        // Hide translation tooltip
        function hideTranslation() {
            translationTooltip.style.display = 'none';
            if (selectedParagraph) {
                selectedParagraph.classList.remove('selected');
                selectedParagraph = null;
            }
        }
        
        // Translate text using free API
        async function translateText(text) {
            const translationDiv = translationTooltip.querySelector('.tooltip-translation');
            
            // Limit text length for API (MyMemory has a 500 character limit)
            const textToTranslate = text.length > 500 ? text.substring(0, 500) : text;
            
            // If text is too long, split it into chunks
            const maxChunkLength = 500; // MyMemory API limit
            
            if (text.length <= maxChunkLength) {
                // Short text - translate directly
                try {
                    const url = `${TRANSLATION_API}?q=${encodeURIComponent(text)}&langpair=en|zh-CN`;
                    const response = await fetch(url);
                    const data = await response.json();
                    
                    if (data.responseStatus === 200 && data.responseData) {
                        const translation = data.responseData.translatedText;
                        translationDiv.textContent = translation;
                        translationDiv.style.color = '#5a3e2b';
                    } else {
                        translationDiv.textContent = '翻译失败,请稍后重试';
                        translationDiv.style.color = '#d9534f';
                    }
                } catch (error) {
                    console.error('Translation error:', error);
                    translationDiv.textContent = '翻译服务暂时不可用';
                    translationDiv.style.color = '#d9534f';
                }
            } else {
                // Long text - split into chunks
                try {
                    // Split text into chunks of maxChunkLength, trying to break at sentence boundaries
                    const chunks = [];
                    let currentChunk = '';
                    
                    // First, try to split by sentence endings
                    const sentences = text.match(/[^.!?。！？]+[.!?。！？]*/g) || [text];
                    
                    for (const sentence of sentences) {
                        if ((currentChunk + sentence).length <= maxChunkLength) {
                            currentChunk += sentence;
                        } else {
                            if (currentChunk) {
                                chunks.push(currentChunk);
                            }
                            // If single sentence is too long, force split by maxChunkLength
                            if (sentence.length > maxChunkLength) {
                                for (let i = 0; i < sentence.length; i += maxChunkLength) {
                                    chunks.push(sentence.substring(i, i + maxChunkLength));
                                }
                                currentChunk = '';
                            } else {
                                currentChunk = sentence;
                            }
                        }
                    }
                    
                    if (currentChunk) {
                        chunks.push(currentChunk);
                    }
                    
                    // Translate each chunk
                    let fullTranslation = '';
                    for (let i = 0; i < chunks.length; i++) {
                        const chunk = chunks[i];
                        const url = `${TRANSLATION_API}?q=${encodeURIComponent(chunk)}&langpair=en|zh-CN`;
                        const response = await fetch(url);
                        const data = await response.json();
                        
                        if (data.responseStatus === 200 && data.responseData) {
                            fullTranslation += data.responseData.translatedText;
                            // Update display with progress
                            translationDiv.textContent = fullTranslation + ' [翻译中...]';
                        } else {
                            fullTranslation += '[翻译失败]';
                        }
                        
                        // Add small delay to avoid rate limiting
                        if (i < chunks.length - 1) {
                            await new Promise(resolve => setTimeout(resolve, 200));
                        }
                    }
                    
                    translationDiv.textContent = fullTranslation;
                    translationDiv.style.color = '#5a3e2b';
                } catch (error) {
                    console.error('Translation error:', error);
                    translationDiv.textContent = '翻译服务暂时不可用';
                    translationDiv.style.color = '#d9534f';
                }
            }
        }
        
        // Add CSS for selected state
        const style = document.createElement('style');
        style.textContent = `
            .selectable {
                cursor: pointer;
                transition: background-color 0.2s ease;
                padding: 2px 4px;
                border-radius: 3px;
            }
            
            .selectable:hover {
                background-color: rgba(212, 167, 106, 0.2);
            }
            
            .selectable.selected {
                background-color: rgba(212, 167, 106, 0.4);
            }
            
            .translation-tooltip {
                animation: fadeIn 0.2s ease;
            }
            
            @keyframes fadeIn {
                from {
                    opacity: 0;
                    transform: translateY(-5px);
                }
                to {
                    opacity: 1;
                    transform: translateY(0);
                }
            }
        `;
        document.head.appendChild(style);
    </script>
    </body>
</html>