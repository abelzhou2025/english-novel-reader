<!DOCTYPE html>

<html lang="zh">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Coca-Cola's New Holiday Ads Went Full AI Again \&amp; Fans Call It 'Intentional Ragebait' - English Novel Reader</title>
<link href="../styles.css" rel="stylesheet"/>
<style>
        body {
            font-family: Georgia, serif;
            background-color: #f9f7f4;
            margin: 0;
            padding: 0;
        }
        
        .article-content {
            max-width: 900px;
            margin: 100px auto 50px;
            padding: 40px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        .back-btn {
            display: inline-block;
            background-color: #5a3e2b;
            color: #fff;
            padding: 10px 20px;
            border-radius: 6px;
            text-decoration: none;
            font-family: 'Microsoft YaHei', sans-serif;
            font-size: 0.95rem;
            transition: all 0.3s ease;
            margin-bottom: 30px;
        }
        
        .back-btn:hover {
            background-color: #7a5c42;
            transform: translateY(-2px);
        }
        
        .article-title {
            font-family: Georgia, serif;
            font-size: 2rem;
            color: #2c2c2c;
            margin-bottom: 30px;
            line-height: 1.3;
            font-weight: 600;
        }
        
        .article-section {
            margin-bottom: 30px;
        }
        
        .section-heading {
            font-family: Georgia, serif;
            font-size: 1.5rem;
            color: #3a3a3a;
            margin-top: 35px;
            margin-bottom: 20px;
            font-weight: 600;
            line-height: 1.4;
        }
        
        .section-subheading {
            font-family: Georgia, serif;
            font-size: 1.2rem;
            color: #4a4a4a;
            margin-top: 25px;
            margin-bottom: 15px;
            font-weight: 600;
            line-height: 1.4;
        }
        
        .paragraph-block {
            margin-bottom: 25px;
        }
        
        .english-text {
            font-family: Georgia, serif;
            font-size: 1.1rem;
            color: #2c2c2c;
            line-height: 1.8;
            margin-bottom: 12px;
        }
        
        .chinese-text {
            font-family: 'Microsoft YaHei', 'SimHei', sans-serif;
            font-size: 1rem;
            color: #666;
            line-height: 1.8;
            padding-left: 20px;
            border-left: 3px solid #d4a76a;
            opacity: 0.7;
        }
        
        @media (max-width: 768px) {
            .article-content {
                margin: 80px 15px 30px;
                padding: 25px;
            }
            
            .article-title {
                font-size: 1.6rem;
            }
            
            .section-heading {
                font-size: 1.3rem;
            }
            
            .english-text {
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
<!-- Top Navigation -->
<nav class="top-nav">
<ul>
<li><a href="../index.html">首页</a></li>
<li><a href="../novels.html">小说</a></li>
<li><a class="active" href="../webnovels.html">网文</a></li>
    <li><a href="../news.html">新闻</a></li>
    <li><a href="../about.html">关于我</a></li>
</ul>
</nav>
<div class="article-content">
<a class="back-btn" href="../webnovels.html">← 返回网文列表</a>
<h1 class="article-title">Coca-Cola's New Holiday Ads Went Full AI Again \&amp; Fans Call It 'Intentional Ragebait'</h1>
<div class="paragraph-block">
<p class="english-text">Coca-Cola brought back its glossy "Holidays Are Coming" campaign with two new spots that look straight out of a storybook---if the storybook were rendered by a very eager AI algorithm.</p>
<p class="chinese-text">可口可乐恢复了其光鲜亮丽的“假期即将到来”营销活动，其中两个新广告看起来就像是故事书一样——如果故事书是由非常热切的人工智能算法渲染的。</p>
</div>
<div class="paragraph-block">

</div>
<div class="paragraph-block">
<p class="english-text">We've got Santa! There are glowing trucks! Is that a parade of sweater-wearing woodland critters craning for a view?! The company says "human storytellers" steered the process while generative tools handled the heavy lifting. Viewers, however, aren't buying the warm-and-fuzzy artificial part of it all.</p>
<p class="chinese-text">我们有圣诞老人！有发光的卡车！这是一群穿着毛衣的林地小动物在伸长脖子观看风景吗？！该公司表示，“人类讲故事者”主导了整个过程，而生成工具则负责处理繁重的工作。然而，观众并不相信这一切温暖而模糊的人造部分。</p>
</div>
<div class="paragraph-block">

</div>
<div class="paragraph-block">
<p class="english-text">On the Coca-Cola YouTube page where the video was posted, the comments don't hold back. "Just because you can, doesn't mean you should," one person wrote. Another jabbed, "Real magic is when you hire an actual artist with a soul," while a common theme surrounding the spot was that people want a Pepsi real bad. And yes, people just want their old ads back, with someone saying, "I miss the old Coke commercials from the 2000s with the polar bears."</p>
<p class="chinese-text">在发布该视频的可口可乐 YouTube 页面上，评论毫不留情。“仅仅因为你可以，并不意味着你应该这样做，”一位网友写道。另一位网友讽刺道，“真正的魔力在于你聘请了一位真正有灵魂的艺术家”，而围绕该现场的一个共同主题是人们非常想要百事可乐。是的，人们只是想要回他们的旧广告，有人说，“我怀念 2000 年代有北极熊的旧可口可乐广告。”</p>
</div>
<div class="paragraph-block">

</div>
<div class="paragraph-block">
<p class="english-text">More From Delish</p>
<p class="chinese-text">更多来自美味</p>
</div>
<div class="paragraph-block">

</div>
<div class="paragraph-block">
<p class="english-text">Watch: Golden Rules Of Making Jam</p>
<p class="chinese-text">观看：制作果酱的黄金法则</p>
</div>
<div class="paragraph-block">

</div>
<div class="paragraph-block">
<p class="english-text">Golden Rules Of Making Jam</p>
<p class="chinese-text">制作果酱的黄金法则</p>
</div>
<div class="paragraph-block">

</div>
<div class="paragraph-block">
<p class="english-text">Delish US</p>
<p class="chinese-text">美味美国</p>
</div>
<div class="paragraph-block">

</div>
<div class="paragraph-block">
<p class="english-text">Current Time 0:37</p>
<p class="chinese-text">当前时间 0:37</p>
</div>
<div class="paragraph-block">

</div>
<div class="paragraph-block">
<p class="english-text">Total Duration 1:39</p>
<p class="chinese-text">总时长 1:39</p>
</div>
<div class="paragraph-block">

</div>
<div class="paragraph-block">
<p class="english-text">This content is imported from youTube. You may be able to find the same content in another format, or you may be able to find more information, at their web site.</p>
<p class="chinese-text">此内容是从 youTube 导入的。您也许能够在他们的网站上找到其他格式的相同内容，或者您​​也许能够找到更多信息。</p>
</div>
<div class="paragraph-block">

</div>
<div class="paragraph-block">
<p class="english-text">This content is imported from Third party. You may be able to find the same content in another format, or you may be able to find more information, at their web site.</p>
<p class="chinese-text">此内容是从第三方导入的。您也许能够在他们的网站上找到其他格式的相同内容，或者您​​也许能够找到更多信息。</p>
</div>
<div class="paragraph-block">

</div>
<div class="paragraph-block">
<p class="english-text">Inside the company, the stance is clear: this is the future---so get used to it. Coca-Cola's generative-AI lead, Pratik Thakar, has framed the approach as pairing heritage with new tech and insists the results land "authentic and emotionally resonant." Creatives behind the work say last year's all-AI attempt took heat, but the craftsmanship improved this season---and average viewers "really enjoyed it."</p>
<p class="chinese-text">公司内部的立场很明确：这就是未来——所以要习惯它。可口可乐的生成人工智能负责人普拉蒂克·塔卡尔(Pratik Thakar)将这种方法定义为将传统与新技术相结合，并坚称结果“真实且能引起情感共鸣”。该作品背后的创意人员表示，去年的全人工智能尝试引起了热议，但本季的工艺有所提高——普通观众“真的很喜欢它”。</p>
</div>
<div class="paragraph-block">

</div>
<div class="paragraph-block">
<p class="english-text">Holiday ads (like the iconic ones from Coca-Cola) are basically visual comfort food; if the textures feel slick or uncanny, people notice. The brand is free to continue experimenting, but it's safe to say the critics will be just as determined to keep roasting. So, yes, the trucks are still coming---but the comments are, too.</p>
<p class="chinese-text">假日广告（如可口可乐的标志性广告）基本上是视觉安慰食品；如果纹理感觉光滑或怪异，人们就会注意到。该品牌可以自由地继续试验，但可以肯定地说，批评者也会同样坚决地继续批评。所以，是的，卡车仍然来了——但评论也来了。</p>
</div>
<div class="paragraph-block">

</div>
<div class="paragraph-block">
<p class="english-text">Read in Cubox</p>
<p class="chinese-text">在 Cubox 中阅读</p>
</div>
<div class="paragraph-block">

</div>
</div>

    <!-- Translation Tooltip HTML -->
    <div class="translation-tooltip" id="translationTooltip" style="display: none; position: fixed; max-width: 400px; background-color: rgba(255, 255, 255, 0.98); border: 2px solid #5a3e2b; border-radius: 8px; padding: 15px; box-shadow: 0 4px 20px rgba(0,0,0,0.2); z-index: 1000; font-family: 'Microsoft YaHei', sans-serif;">
        <div class="tooltip-translation" style="color: #5a3e2b; font-size: 1rem; font-weight: 500; line-height: 1.6;">翻译中...</div>
    </div>
    <!-- Translation Script -->
    <script>
        // Article Translation Features
        // Features: Click-to-translate near cursor
        
        // Global variables
        let selectedParagraph = null;
        
        // Translation API (using free MyMemory API)
        const TRANSLATION_API = 'https://api.mymemory.translated.net/get';
        
        // DOM elements
        let translationTooltip;
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Get DOM elements
            translationTooltip = document.getElementById('translationTooltip');
            
            // Add click listener to close tooltip when clicking outside
            document.addEventListener('click', function(e) {
                // Check if click is outside tooltip and not on a selectable paragraph
                if (translationTooltip && 
                    !translationTooltip.contains(e.target) && 
                    !e.target.classList.contains('selectable')) {
                    hideTranslation();
                }
            });
            
            // Add selectable class to all English text paragraphs in articles
            const englishParagraphs = document.querySelectorAll('.english-text');
            englishParagraphs.forEach(paragraph => {
                // Only make English text selectable
                if (paragraph.textContent.trim()) {
                    paragraph.classList.add('selectable');
                    
                    // Add click listener for translation
                    paragraph.addEventListener('click', function(e) {
                        e.stopPropagation(); // Prevent document click from firing
                        handleParagraphClick(this, e);
                    });
                }
            });
        });
        
        // Handle paragraph click for translation
        function handleParagraphClick(element, event) {
            // Remove previous selection
            if (selectedParagraph) {
                selectedParagraph.classList.remove('selected');
            }
            
            // Mark as selected
            element.classList.add('selected');
            selectedParagraph = element;
            
            // Get the text to translate
            const textToTranslate = element.textContent;
            
            // Position tooltip near the click
            positionTooltip(event);
            
            // Show tooltip with loading state
            showTranslation(textToTranslate);
            
            // Fetch translation
            translateText(textToTranslate);
        }
        
        // Position tooltip near cursor but ensure it stays on screen
        function positionTooltip(event) {
            const tooltip = translationTooltip;
            const offset = 15; // Offset from cursor
            
            // Get viewport dimensions
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            // Initial position near cursor
            let left = event.pageX + offset;
            let top = event.pageY + offset;
            
            // Show tooltip temporarily to get its dimensions
            tooltip.style.display = 'block';
            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
            
            // Get tooltip dimensions
            const tooltipRect = tooltip.getBoundingClientRect();
            const tooltipWidth = tooltipRect.width;
            const tooltipHeight = tooltipRect.height;
            
            // Adjust if tooltip goes off right edge
            if (event.clientX + tooltipWidth + offset > viewportWidth) {
                left = event.pageX - tooltipWidth - offset;
            }
            
            // Adjust if tooltip goes off bottom edge
            if (event.clientY + tooltipHeight + offset > viewportHeight) {
                top = event.pageY - tooltipHeight - offset;
            }
            
            // Ensure tooltip doesn't go off left or top edges
            if (left < 10) left = 10;
            if (top < 80) top = 80; // Account for top nav
            
            // Set final position
            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
        }
        
        // Show translation tooltip
        function showTranslation(originalText) {
            const translationDiv = translationTooltip.querySelector('.tooltip-translation');
            
            // Show loading state
            translationDiv.textContent = '翻译中...';
            translationDiv.style.color = '#999';
            
            // Show tooltip
            translationTooltip.style.display = 'block';
        }
        
        // Hide translation tooltip
        function hideTranslation() {
            translationTooltip.style.display = 'none';
            if (selectedParagraph) {
                selectedParagraph.classList.remove('selected');
                selectedParagraph = null;
            }
        }
        
        // Translate text using free API
        async function translateText(text) {
            const translationDiv = translationTooltip.querySelector('.tooltip-translation');
            
            // Limit text length for API (MyMemory has a 500 character limit)
            const textToTranslate = text.length > 500 ? text.substring(0, 500) : text;
            
            // If text is too long, split it into chunks
            const maxChunkLength = 500; // MyMemory API limit
            
            if (text.length <= maxChunkLength) {
                // Short text - translate directly
                try {
                    const url = `${TRANSLATION_API}?q=${encodeURIComponent(text)}&langpair=en|zh-CN`;
                    const response = await fetch(url);
                    const data = await response.json();
                    
                    if (data.responseStatus === 200 && data.responseData) {
                        const translation = data.responseData.translatedText;
                        translationDiv.textContent = translation;
                        translationDiv.style.color = '#5a3e2b';
                    } else {
                        translationDiv.textContent = '翻译失败,请稍后重试';
                        translationDiv.style.color = '#d9534f';
                    }
                } catch (error) {
                    console.error('Translation error:', error);
                    translationDiv.textContent = '翻译服务暂时不可用';
                    translationDiv.style.color = '#d9534f';
                }
            } else {
                // Long text - split into chunks
                try {
                    // Split text into chunks of maxChunkLength, trying to break at sentence boundaries
                    const chunks = [];
                    let currentChunk = '';
                    
                    // First, try to split by sentence endings
                    const sentences = text.match(/[^.!?。！？]+[.!?。！？]*/g) || [text];
                    
                    for (const sentence of sentences) {
                        if ((currentChunk + sentence).length <= maxChunkLength) {
                            currentChunk += sentence;
                        } else {
                            if (currentChunk) {
                                chunks.push(currentChunk);
                            }
                            // If single sentence is too long, force split by maxChunkLength
                            if (sentence.length > maxChunkLength) {
                                for (let i = 0; i < sentence.length; i += maxChunkLength) {
                                    chunks.push(sentence.substring(i, i + maxChunkLength));
                                }
                                currentChunk = '';
                            } else {
                                currentChunk = sentence;
                            }
                        }
                    }
                    
                    if (currentChunk) {
                        chunks.push(currentChunk);
                    }
                    
                    // Translate each chunk
                    let fullTranslation = '';
                    for (let i = 0; i < chunks.length; i++) {
                        const chunk = chunks[i];
                        const url = `${TRANSLATION_API}?q=${encodeURIComponent(chunk)}&langpair=en|zh-CN`;
                        const response = await fetch(url);
                        const data = await response.json();
                        
                        if (data.responseStatus === 200 && data.responseData) {
                            fullTranslation += data.responseData.translatedText;
                            // Update display with progress
                            translationDiv.textContent = fullTranslation + ' [翻译中...]';
                        } else {
                            fullTranslation += '[翻译失败]';
                        }
                        
                        // Add small delay to avoid rate limiting
                        if (i < chunks.length - 1) {
                            await new Promise(resolve => setTimeout(resolve, 200));
                        }
                    }
                    
                    translationDiv.textContent = fullTranslation;
                    translationDiv.style.color = '#5a3e2b';
                } catch (error) {
                    console.error('Translation error:', error);
                    translationDiv.textContent = '翻译服务暂时不可用';
                    translationDiv.style.color = '#d9534f';
                }
            }
        }
        
        // Add CSS for selected state
        const style = document.createElement('style');
        style.textContent = `
            .selectable {
                cursor: pointer;
                transition: background-color 0.2s ease;
                padding: 2px 4px;
                border-radius: 3px;
            }
            
            .selectable:hover {
                background-color: rgba(212, 167, 106, 0.2);
            }
            
            .selectable.selected {
                background-color: rgba(212, 167, 106, 0.4);
            }
            
            .translation-tooltip {
                animation: fadeIn 0.2s ease;
            }
            
            @keyframes fadeIn {
                from {
                    opacity: 0;
                    transform: translateY(-5px);
                }
                to {
                    opacity: 1;
                    transform: translateY(0);
                }
            }
        `;
        document.head.appendChild(style);
    </script>
    </body>
</html>